<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>2017Spring 協同產品設計實習 (40423104)</title><link href="./" rel="alternate"></link><link href="./feeds/all.atom.xml" rel="self"></link><id>./</id><updated>2017-06-01T17:00:00+08:00</updated><entry><title>W15 正齒輪協同練習</title><link href="./%E6%AD%A3%E9%BD%92%E8%BC%AA%E5%8D%94%E5%90%8C%E7%B7%B4%E7%BF%92.html" rel="alternate"></link><published>2017-06-01T17:00:00+08:00</published><updated>2017-06-01T17:00:00+08:00</updated><author><name>40423104-YanSyuan</name></author><id>tag:,2017-06-01:./正齒輪協同練習.html</id><summary type="html">&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;請以 W15 練習為網誌標題, 800x600 為畫布大小, 在畫布正中央畫一個半徑為 250 畫素, 壓力角 20, 齒數為 36 齒, 且只有上半齒形的漸開線正齒輪輪廓.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;完成後, 請在正齒輪中央寫上自己的學號, 並建立第二個 800x600 的畫布, 請畫出只有一齒輪廓, 且充滿畫布 80% 範圍的正齒輪, 且該齒輪廓下方水平線, 連接兩端齒根圓點交的直線以紅色繪製, 且在齒輪下方以藍色字元寫上自己的學號.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;請各學員在各自 github 倉儲中的 data/py 目錄中, 編寫一個可以採圓心座標, 節圓半徑, 齒數, 壓力角與定位角度作為輸入的齒輪程式函式, 交由組長從各組員的 submodule 設定中呼叫導入, 以便在各分組的網頁中完成一個畫出所有組員協同繪圖的齒輪減速組圖, 且各齒輪正中心必須寫上組員學號, 各組按照學號大小排序, 分別由最右邊齒數 16 齒開始囓合, 依序增加 2 齒, 當排至平面四齒囓合後, 第五位組員則以垂直方向向下囓合兩個齒輪後, 轉由右至左水平排列, 直至所有組員均各提供一個協同囓合用的齒輪為止.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;請依照上述規劃, 在 Onshape 完成相同齒輪組的囓合協同繪圖.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;各組員與組員請同時用 Youtube 與 vimeo, 紀錄上述各階段程式編寫與繪圖配置的 mp4 影片檔案, 標題為"協同產品設計實習第十五週練習".&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;


&lt;!-- 導入 Brython 標準程式庫 --&gt;

&lt;script src="../data/Brython-3.3.1/brython.js"&gt;&lt;/script&gt;

&lt;script src="../data/Brython-3.3.1/brython_stdlib.js"&gt;&lt;/script&gt;

&lt;!-- 啟動 Brython --&gt;

&lt;script&gt;
window.onload=function(){
// 設定 data/py 為共用程式路徑
brython({debug:1, pythonpath:['./../data/py']});
}
&lt;/script&gt;

&lt;!-- 以下實際利用  Brython 繪圖--&gt;

&lt;canvas id="gearW15" width="800" height="600"&gt;&lt;/canvas&gt;

&lt;div id="gearW15_div" width="800" height="20"&gt;&lt;/div&gt;

&lt;script type="text/python3"&gt;
from browser import document as doc
import math
# deg 為角度轉為徑度的轉換因子
deg = math.pi/180.
# 定義 Spur 類別
class Spur(object):
    def __init__(self, ctx):
        self.ctx = ctx

    def create_line(self, x1, y1, x2, y2, width=3, fill="red"):
        self.ctx.beginPath()
        self.ctx.lineWidth = width
        self.ctx.moveTo(x1, y1)
        self.ctx.lineTo(x2, y2)
        self.ctx.strokeStyle = fill
        self.ctx.stroke()
    #
    # 定義一個繪正齒輪的繪圖函式
    # midx 為齒輪圓心 x 座標
    # midy 為齒輪圓心 y 座標
    # rp 為節圓半徑, n 為齒數
    # pa 為壓力角 (deg)
    # rot 為旋轉角 (deg)
    # 已經針對 n 大於等於 52 齒時的繪圖錯誤修正, 因為 base circle 與齒根圓大小必須進行判斷
    def Gear(self, midx, midy, rp, n=20, pa=20, color="black"):
        # 齒輪漸開線分成 15 線段繪製
        imax = 15
        # 在輸入的畫布上繪製直線, 由圓心到節圓 y 軸頂點畫一直線
        self.create_line(midx, midy, midx, midy-rp)
        # 畫出 rp 圓, 畫圓函式尚未定義
        #create_oval(midx-rp, midy-rp, midx+rp, midy+rp, width=2)
        # a 為模數 (代表公制中齒的大小), 模數為節圓直徑(稱為節徑)除以齒數
        # 模數也就是齒冠大小
        a=2*rp/n
        # d 為齒根大小, 為模數的 1.157 或 1.25倍, 這裡採 1.25 倍
        d=2.5*rp/n
        # ra 為齒輪的外圍半徑
        ra=rp+a
        # 畫出 ra 圓, 畫圓函式尚未定義
        #create_oval(midx-ra, midy-ra, midx+ra, midy+ra, width=1)
        # rb 則為齒輪的基圓半徑
        # 基圓為漸開線長齒之基準圓
        rb=rp*math.cos(pa*deg)
        # 畫出 rb 圓 (基圓), 畫圓函式尚未定義
        #create_oval(midx-rb, midy-rb, midx+rb, midy+rb, width=1)
        # rd 為齒根圓半徑
        rd=rp-d
        # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd
        # 畫出 rd 圓 (齒根圓), 畫圓函式尚未定義
        #create_oval(midx-rd, midy-rd, midx+rd, midy+rd, width=1)
        # dr 則為基圓到齒頂圓半徑分成 imax 段後的每段半徑增量大小
        # 將圓弧分成 imax 段來繪製漸開線
        # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd
        if rd&gt;rb:
            dr = (ra-rd)/imax
        else:
            dr=(ra-rb)/imax
        # tan(pa*deg)-pa*deg 為漸開線函數
        sigma=math.pi/(2*n)+math.tan(pa*deg)-pa*deg
        for j in range(n):
            ang=-2.*j*math.pi/n+sigma
            ang2=2.*j*math.pi/n+sigma
            lxd=midx+rd*math.sin(ang2-2.*math.pi/n)
            lyd=midy-rd*math.cos(ang2-2.*math.pi/n)
            for i in range(imax+1):
                # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd
                if rd&gt;rb:
                    r=rd+i*dr
                else:
                    r=rb+i*dr
                theta=math.sqrt((r*r)/(rb*rb)-1.)
                alpha=theta-math.atan(theta)
                xpt=r*math.sin(alpha-ang)
                ypt=r*math.cos(alpha-ang)
                xd=rd*math.sin(-ang)
                yd=rd*math.cos(-ang)
                # i=0 時, 繪線起點由齒根圓上的點, 作為起點
                if(i==0):
                    last_x = midx+xd
                    last_y = midy-yd
                # 由左側齒根圓作為起點, 除第一點 (xd,yd) 齒根圓上的起點外, 其餘的 (xpt,ypt)則為漸開線上的分段點
                self.create_line((midx+xpt),(midy-ypt),(last_x),(last_y),fill=color)
                # 最後一點, 則為齒頂圓
                if(i==imax):
                    lfx=midx+xpt
                    lfy=midy-ypt
                last_x = midx+xpt
                last_y = midy-ypt
            # the line from last end of dedendum point to the recent
            # end of dedendum point
            # lxd 為齒根圓上的左側 x 座標, lyd 則為 y 座標
            # 下列為齒根圓上用來近似圓弧的直線
            self.create_line((lxd),(lyd),(midx+xd),(midy-yd),fill=color)
            for i in range(imax+1):
                # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd
                if rd&gt;rb:
                    r=rd+i*dr
                else:
                    r=rb+i*dr
                theta=math.sqrt((r*r)/(rb*rb)-1.)
                alpha=theta-math.atan(theta)
                xpt=r*math.sin(ang2-alpha)
                ypt=r*math.cos(ang2-alpha)
                xd=rd*math.sin(ang2)
                yd=rd*math.cos(ang2)
                # i=0 時, 繪線起點由齒根圓上的點, 作為起點
                if(i==0):
                    last_x = midx+xd
                    last_y = midy-yd
                # 由右側齒根圓作為起點, 除第一點 (xd,yd) 齒根圓上的起點外, 其餘的 (xpt,ypt)則為漸開線上的分段點
                self.create_line((midx+xpt),(midy-ypt),(last_x),(last_y),fill=color)
                # 最後一點, 則為齒頂圓
                if(i==imax):
                    rfx=midx+xpt
                    rfy=midy-ypt
                last_x = midx+xpt
                last_y = midy-ypt
            # lfx 為齒頂圓上的左側 x 座標, lfy 則為 y 座標
            # 下列為齒頂圓上用來近似圓弧的直線
            self.create_line(lfx,lfy,rfx,rfy,fill=color)
canvas = doc['gearW15']
ctx = canvas.getContext("2d")
x = (canvas.width)/2
y = (canvas.height)/2
r = 0.8*(canvas.height/2)
# 齒數
n = 36
# 壓力角
pa = 20
Spur(ctx).Gear(x, y, r, n, pa, "blue")

ctx.beginPath()
ctx.lineWidth = "600"
ctx.strokeStyle = "white"
ctx.moveTo(0,600)
ctx.lineTo(800,600)
ctx.stroke()

ctx.beginPath()
ctx.fillStyle = "#BA55D3"
ctx.font = "30px ScriptS"
ctx.fillText("40423104", (canvas.width)/2-60, (canvas.height)/2+25)
ctx.stroke()

&lt;/script&gt;

&lt;!-- 以下實際利用  Brython 繪圖--&gt;

&lt;canvas id="gearone" width="800" height="600"&gt;&lt;/canvas&gt;

&lt;div id="gearone_div" width="800" height="20"&gt;&lt;/div&gt;

&lt;script type="text/python3"&gt;
from browser import document as doc
import math
# deg 為角度轉為徑度的轉換因子
deg = math.pi/180.
# 定義 Spur 類別
class Spur(object):
    def __init__(self, ctx):
        self.ctx = ctx

    def create_line(self, x1, y1, x2, y2, width=3, fill="red"):
        self.ctx.beginPath()
        self.ctx.lineWidth = width
        self.ctx.moveTo(x1, y1)
        self.ctx.lineTo(x2, y2)
        self.ctx.strokeStyle = fill
        self.ctx.stroke()
    #
    # 定義一個繪正齒輪的繪圖函式
    # midx 為齒輪圓心 x 座標
    # midy 為齒輪圓心 y 座標
    # rp 為節圓半徑, n 為齒數
    # pa 為壓力角 (deg)
    # rot 為旋轉角 (deg)
    # 已經針對 n 大於等於 52 齒時的繪圖錯誤修正, 因為 base circle 與齒根圓大小必須進行判斷
    def Gear(self, midx, midy, rp, n=20, pa=20, color="black"):
        # 齒輪漸開線分成 15 線段繪製
        imax = 15
        # 在輸入的畫布上繪製直線, 由圓心到節圓 y 軸頂點畫一直線
        self.create_line(midx, midy, midx, midy-rp)
        # 畫出 rp 圓, 畫圓函式尚未定義
        #create_oval(midx-rp, midy-rp, midx+rp, midy+rp, width=2)
        # a 為模數 (代表公制中齒的大小), 模數為節圓直徑(稱為節徑)除以齒數
        # 模數也就是齒冠大小
        a=2*rp/n
        # d 為齒根大小, 為模數的 1.157 或 1.25倍, 這裡採 1.25 倍
        d=2.5*rp/n
        # ra 為齒輪的外圍半徑
        ra=rp+a
        # 畫出 ra 圓, 畫圓函式尚未定義
        #create_oval(midx-ra, midy-ra, midx+ra, midy+ra, width=1)
        # rb 則為齒輪的基圓半徑
        # 基圓為漸開線長齒之基準圓
        rb=rp*math.cos(pa*deg)
        # 畫出 rb 圓 (基圓), 畫圓函式尚未定義
        #create_oval(midx-rb, midy-rb, midx+rb, midy+rb, width=1)
        # rd 為齒根圓半徑
        rd=rp-d
        # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd
        # 畫出 rd 圓 (齒根圓), 畫圓函式尚未定義
        #create_oval(midx-rd, midy-rd, midx+rd, midy+rd, width=1)
        # dr 則為基圓到齒頂圓半徑分成 imax 段後的每段半徑增量大小
        # 將圓弧分成 imax 段來繪製漸開線
        # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd
        if rd&gt;rb:
            dr = (ra-rd)/imax
        else:
            dr=(ra-rb)/imax
        # tan(pa*deg)-pa*deg 為漸開線函數
        sigma=math.pi/(2*n)+math.tan(pa*deg)-pa*deg
        for j in range(n):
            ang=-2.*j*math.pi/n+sigma
            ang2=2.*j*math.pi/n+sigma
            lxd=midx+rd*math.sin(ang2-2.*math.pi/n)
            lyd=midy-rd*math.cos(ang2-2.*math.pi/n)
            for i in range(imax+1):
                # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd
                if rd&gt;rb:
                    r=rd+i*dr
                else:
                    r=rb+i*dr
                theta=math.sqrt((r*r)/(rb*rb)-1.)
                alpha=theta-math.atan(theta)
                xpt=r*math.sin(alpha-ang)
                ypt=r*math.cos(alpha-ang)
                xd=rd*math.sin(-ang)
                yd=rd*math.cos(-ang)
                # i=0 時, 繪線起點由齒根圓上的點, 作為起點
                if(i==0):
                    last_x = midx+xd
                    last_y = midy-yd
                # 由左側齒根圓作為起點, 除第一點 (xd,yd) 齒根圓上的起點外, 其餘的 (xpt,ypt)則為漸開線上的分段點
                self.create_line((midx+xpt),(midy-ypt),(last_x),(last_y),fill=color)
                # 最後一點, 則為齒頂圓
                if(i==imax):
                    lfx=midx+xpt
                    lfy=midy-ypt
                last_x = midx+xpt
                last_y = midy-ypt
            # the line from last end of dedendum point to the recent
            # end of dedendum point
            # lxd 為齒根圓上的左側 x 座標, lyd 則為 y 座標
            # 下列為齒根圓上用來近似圓弧的直線
            self.create_line((lxd),(lyd),(midx+xd),(midy-yd),fill=color)
            for i in range(imax+1):
                # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd
                if rd&gt;rb:
                    r=rd+i*dr
                else:
                    r=rb+i*dr
                theta=math.sqrt((r*r)/(rb*rb)-1.)
                alpha=theta-math.atan(theta)
                xpt=r*math.sin(ang2-alpha)
                ypt=r*math.cos(ang2-alpha)
                xd=rd*math.sin(ang2)
                yd=rd*math.cos(ang2)
                # i=0 時, 繪線起點由齒根圓上的點, 作為起點
                if(i==0):
                    last_x = midx+xd
                    last_y = midy-yd
                # 由右側齒根圓作為起點, 除第一點 (xd,yd) 齒根圓上的起點外, 其餘的 (xpt,ypt)則為漸開線上的分段點
                self.create_line((midx+xpt),(midy-ypt),(last_x),(last_y),fill=color)
                # 最後一點, 則為齒頂圓
                if(i==imax):
                    rfx=midx+xpt
                    rfy=midy-ypt
                last_x = midx+xpt
                last_y = midy-ypt
            # lfx 為齒頂圓上的左側 x 座標, lfy 則為 y 座標
            # 下列為齒頂圓上用來近似圓弧的直線
            self.create_line(lfx,lfy,rfx,rfy,fill=color)
canvas = doc['gearone']
ctx = canvas.getContext("2d")
x = (canvas.width)/2
y = (canvas.height)/2+2400
r = 8*(canvas.height/2)
# 齒數
n = 20
# 壓力角
pa = 20
Spur(ctx).Gear(x, y, r, n, pa, "black")

ctx.beginPath()
ctx.fillStyle = "#BA55D3"
ctx.font = "30px ScriptS"
ctx.fillText("40423104", (canvas.width)/2-60, (canvas.height)/2+25)
ctx.stroke()


&lt;/script&gt;

&lt;!-- 導入 Brython 標準程式庫 --&gt;

&lt;script src="../data/Brython-3.3.1/brython.js"&gt;&lt;/script&gt;

&lt;script src="../data/Brython-3.3.1/brython_stdlib.js"&gt;&lt;/script&gt;

&lt;!-- 啟動 Brython --&gt;

&lt;script&gt;
window.onload=function(){
// 設定 data/py 為共用程式路徑
brython({debug:1, pythonpath:['./../data/py']});
}
&lt;/script&gt;

&lt;!-- 以下實際利用  Brython 繪圖--&gt;

&lt;canvas id='gear3' width='1600' height='1000'&gt;&lt;/canvas&gt;

&lt;script type="text/python3"&gt;
# 導入 browser 模組中的 document, 並設為 doc 變數
from browser import document as doc
import math
# deg 為角度轉為徑度的轉換因子
deg = math.pi/180.
# 定義 Spur 類別
class Spur(object):
    def __init__(self, ctx):
        self.ctx = ctx

    def create_line(self, x1, y1, x2, y2, width=3, fill="red"):
        self.ctx.beginPath()
        self.ctx.lineWidth = width
        self.ctx.moveTo(x1, y1)
        self.ctx.lineTo(x2, y2)
        self.ctx.strokeStyle = fill
        self.ctx.stroke()
    #
    # 定義一個繪正齒輪的繪圖函式
    # midx 為齒輪圓心 x 座標
    # midy 為齒輪圓心 y 座標
    # rp 為節圓半徑, n 為齒數
    # pa 為壓力角 (deg)
    # rot 為旋轉角 (deg)
    # 已經針對 n 大於等於 52 齒時的繪圖錯誤修正, 因為 base circle 與齒根圓大小必須進行判斷
    def Gear(self, midx, midy, rp, n=20, pa=20, color="black"):
        # 齒輪漸開線分成 15 線段繪製
        imax = 15
        # 在輸入的畫布上繪製直線, 由圓心到節圓 y 軸頂點畫一直線
        self.create_line(midx, midy, midx, midy-rp)
        # 畫出 rp 圓, 畫圓函式尚未定義
        #create_oval(midx-rp, midy-rp, midx+rp, midy+rp, width=2)
        # a 為模數 (代表公制中齒的大小), 模數為節圓直徑(稱為節徑)除以齒數
        # 模數也就是齒冠大小
        a=2*rp/n
        # d 為齒根大小, 為模數的 1.157 或 1.25倍, 這裡採 1.25 倍
        d=2.5*rp/n
        # ra 為齒輪的外圍半徑
        ra=rp+a
        # 畫出 ra 圓, 畫圓函式尚未定義
        #create_oval(midx-ra, midy-ra, midx+ra, midy+ra, width=1)
        # rb 則為齒輪的基圓半徑
        # 基圓為漸開線長齒之基準圓
        rb=rp*math.cos(pa*deg)
        # 畫出 rb 圓 (基圓), 畫圓函式尚未定義
        #create_oval(midx-rb, midy-rb, midx+rb, midy+rb, width=1)
        # rd 為齒根圓半徑
        rd=rp-d
        # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd
        # 畫出 rd 圓 (齒根圓), 畫圓函式尚未定義
        #create_oval(midx-rd, midy-rd, midx+rd, midy+rd, width=1)
        # dr 則為基圓到齒頂圓半徑分成 imax 段後的每段半徑增量大小
        # 將圓弧分成 imax 段來繪製漸開線
        # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd
        if rd&gt;rb:
            dr = (ra-rd)/imax
        else:
            dr=(ra-rb)/imax
        # tan(pa*deg)-pa*deg 為漸開線函數
        sigma=math.pi/(2*n)+math.tan(pa*deg)-pa*deg
        for j in range(n):
            ang=-2.*j*math.pi/n+sigma
            ang2=2.*j*math.pi/n+sigma
            lxd=midx+rd*math.sin(ang2-2.*math.pi/n)
            lyd=midy-rd*math.cos(ang2-2.*math.pi/n)
            for i in range(imax+1):
                # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd
                if rd&gt;rb:
                    r=rd+i*dr
                else:
                    r=rb+i*dr
                theta=math.sqrt((r*r)/(rb*rb)-1.)
                alpha=theta-math.atan(theta)
                xpt=r*math.sin(alpha-ang)
                ypt=r*math.cos(alpha-ang)
                xd=rd*math.sin(-ang)

                yd=rd*math.cos(-ang)
                # i=0 時, 繪線起點由齒根圓上的點, 作為起點
                if(i==0):
                    last_x = midx+xd
                    last_y = midy-yd
                # 由左側齒根圓作為起點, 除第一點 (xd,yd) 齒根圓上的起點外, 其餘的 (xpt,ypt)則為漸開線上的分段點
                self.create_line((midx+xpt),(midy-ypt),(last_x),(last_y),fill=color)
                # 最後一點, 則為齒頂圓
                if(i==imax):
                    lfx=midx+xpt
                    lfy=midy-ypt
                last_x = midx+xpt
                last_y = midy-ypt
            # the line from last end of dedendum point to the recent
            # end of dedendum point
            # lxd 為齒根圓上的左側 x 座標, lyd 則為 y 座標
            # 下列為齒根圓上用來近似圓弧的直線
            self.create_line((lxd),(lyd),(midx+xd),(midy-yd),fill=color)
            for i in range(imax+1):
                # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd
                if rd&gt;rb:
                    r=rd+i*dr
                else:
                    r=rb+i*dr
                theta=math.sqrt((r*r)/(rb*rb)-1.)
                alpha=theta-math.atan(theta)
                xpt=r*math.sin(ang2-alpha)
                ypt=r*math.cos(ang2-alpha)
                xd=rd*math.sin(ang2)
                yd=rd*math.cos(ang2)
                # i=0 時, 繪線起點由齒根圓上的點, 作為起點
                if(i==0):
                    last_x = midx+xd
                    last_y = midy-yd
                # 由右側齒根圓作為起點, 除第一點 (xd,yd) 齒根圓上的起點外, 其餘的 (xpt,ypt)則為漸開線上的分段點
                self.create_line((midx+xpt),(midy-ypt),(last_x),(last_y),fill=color)
                # 最後一點, 則為齒頂圓
                if(i==imax):
                    rfx=midx+xpt
                    rfy=midy-ypt
                last_x = midx+xpt
                last_y = midy-ypt
            # lfx 為齒頂圓上的左側 x 座標, lfy 則為 y 座標
            # 下列為齒頂圓上用來近似圓弧的直線
            self.create_line(lfx,lfy,rfx,rfy,fill=color)

# 準備在 id="gear3" 的 canvas 中繪圖
canvas = doc["gear3"]
ctx = canvas.getContext("2d")

# 模數決定齒的尺寸大小, 囓合齒輪組必須有相同的模數與壓力角
# 壓力角 pa 單位為角度
pa = 20
# 第1齒輪齒數
n1 = 12
# 第2齒輪齒數
n2 = 14
# 第3齒輪齒數
n3 = 16
# 第4齒輪齒數
n4 = 20
# 第5齒輪齒數
n5 = 22
# 第6齒輪齒數
n6 = 24
# 第7齒輪齒數
n7 = 26
# 第8齒輪齒數
n8 = 28
# m 為模數, 根據畫布的寬度, 計算適合的模數大小
m = (0.6*canvas.width)/(n1+n2+n3+n4)
# 根據模數 m, 計算各齒輪的節圓半徑
rp1 = m*n1/2
rp2 = m*n2/2
rp3 = m*n3/2
rp4 = m*n4/2
rp5 = m*n5/2
rp6 = m*n6/2
rp7 = m*n7/2
rp8 = m*n8/2
#單一正齒輪繪圖呼叫格式 Spur(ctx).Gear(x, y, r, n, pa, "black")
# 開始繪製囓合齒輪輪廓
# 繪圖第1齒輪的圓心座標, 因為希望繪圖佔去 canvas.width 的 80%, 所以兩邊各預留 10% 距離
x1 = canvas.width*0.05+rp1
# y 方向繪圖區域上方預留 canvas.height 的 20%
y1 = canvas.height*0.1+rp1
# 第2齒輪的圓心座標, 假設排列成水平, 表示各齒輪圓心 y 座標相同
x2 = x1 + rp1 + rp2
y2 = y1
# 第3齒輪的圓心座標
x3 = x1 + rp1 + 2*rp2 + rp3
y3 = y1

# 第4齒輪的圓心座標
x4 = x1 + rp1 + 2*rp2 + 2*rp3+rp4
y4 = y1

# 第5齒輪的圓心座標
x5 = x1 + rp1 + 2*rp2 + 2*rp3+rp4
y5 = y4 + rp4 + rp5

# 第6齒輪的圓心座標
x6 =x1 + rp1 + 2*rp2 + 2*rp3+rp4
y6 = y5 + rp5 + rp6

# 第7齒輪的圓心座標
x7 =x6-rp6-rp7
y7 = y5 + rp5 + rp6

# 第8齒輪的圓心座標
x8 = x7-rp7-rp8
y8 = y5+rp5+rp6

# 將第1齒輪順時鐘轉 90 度, 也就是 math.pi/2
# 使用 ctx.save() 與 ctx.restore() 以確保各齒輪以相對座標進行旋轉繪圖
ctx.save()
# translate to the origin of second gear
ctx.translate(x1, y1)
# rotate to engage
ctx.rotate(math.pi/2)
# put it back
ctx.translate(-x1, -y1)
# 繪製第一個齒輪輪廓
Spur(ctx).Gear(x1, y1, rp1, n1, pa, "purple")
ctx.restore()

ctx.beginPath()
ctx.fillStyle = "#0000FF"
ctx.font = "20px ScriptS"
ctx.fillText("40423101 ",x1-20, y1)
ctx.stroke()

# 將第2齒輪逆時鐘轉 90 度之後, 再多轉一齒, 以便與第1齒輪進行囓合
ctx.save()
# translate to the origin of second gear
ctx.translate(x2, y2)
# rotate to engage
ctx.rotate(-math.pi/2-math.pi/n2)
# put it back
ctx.translate(-x2, -y2)
Spur(ctx).Gear(x2, y2, rp2, n2, pa, "red")
ctx.restore()

ctx.beginPath()
ctx.fillStyle = "#0000FF"
ctx.font = "20px ScriptS"
ctx.fillText("40423103 ",x2-20, y2)
ctx.stroke()

# 將第3齒輪逆時鐘轉 90 度之後, 再往回轉第2齒輪定位帶動轉角, 然後再逆時鐘多轉一齒, 以便與第2齒輪進行囓合
ctx.save()
# translate to the origin of second gear
ctx.translate(x3, y3)
# rotate to engage
# math.pi+math.pi/n2 為第2齒輪從順時鐘轉 90 度之後, 必須配合目前的標記線所作的齒輪 2 轉動角度, 要轉換到齒輪3 的轉動角度
# 必須乘上兩齒輪齒數的比例, 若齒輪2 大, 則齒輪3 會轉動較快
# 第1個 -math.pi/2 為將原先垂直的第3齒輪定位線逆時鐘旋轉 90 度
# -math.pi/n3 則是第3齒與第2齒定位線重合後, 必須再逆時鐘多轉一齒的轉角, 以便進行囓合
# (math.pi+math.pi/n2)*n2/n3 則是第2齒原定位線為順時鐘轉動 90 度, 
# 但是第2齒輪為了與第1齒輪囓合, 已經距離定位線, 多轉了 180 度, 再加上第2齒輪的一齒角度, 因為要帶動第3齒輪定位, 
# 這個修正角度必須要再配合第2齒與第3齒的轉速比加以轉換成第3齒輪的轉角, 因此乘上 n2/n3
ctx.rotate(-math.pi/2-math.pi/n3+(math.pi+math.pi/n2)*n2/n3)
# put it back
ctx.translate(-x3, -y3)
Spur(ctx).Gear(x3, y3, rp3, n3, pa, "blue")
ctx.restore()

ctx.beginPath()
ctx.fillStyle = "#BA55D3"
ctx.font = "20px ScriptS"
ctx.fillText("40423104 ",x3-20, y3)
ctx.stroke()

# 將第4齒輪逆時鐘轉 90 度之後, 再往回轉第3齒輪定位帶動轉角, 然後再逆時鐘多轉一齒, 以便與第2齒輪進行囓合
ctx.save()
# translate to the origin of second gear
ctx.translate(x4, y4)
# rotate to engage
ctx.rotate(math.pi/2-math.pi/n4+(math.pi+math.pi/n3)*n3/n4*2)
# put it back
ctx.translate(-x4, -y4)
Spur(ctx).Gear(x4, y4, rp4, n4, pa, "green")
ctx.restore()

ctx.beginPath()
ctx.fillStyle = "#BA55D3"
ctx.font = "20px ScriptS"
ctx.fillText("40423157 ",x4-20, y4)
ctx.stroke()


# 將第5齒輪逆時鐘轉 90 度之後, 再往回轉第3齒輪定位帶動轉角, 然後再逆時鐘多轉一齒, 以便與第2齒輪進行囓合
ctx.save()
# translate to the origin of second gear
ctx.translate(x5, y5)
# rotate to engage
ctx.rotate(math.pi/2-math.pi/n5+(math.pi+math.pi/n4)*n4/n5*2)
# put it back
ctx.translate(-x5, -y5)
Spur(ctx).Gear(x5, y5, rp5, n5, pa, "red")
ctx.restore()

ctx.beginPath()
ctx.fillStyle = "#0000FF"
ctx.font = "20px ScriptS"
ctx.fillText("40423149 ",x5-20, y5)
ctx.stroke()


# 將第6齒輪逆時鐘轉 90 度之後, 再往回轉第3齒輪定位帶動轉角, 然後再逆時鐘多轉一齒, 以便與第2齒輪進行囓合
ctx.save()
# translate to the origin of second gear
ctx.translate(x6, y6)
# rotate to engage
ctx.rotate(math.pi/2-math.pi/n6+(math.pi+math.pi/n5)*n5/n6*2)
# put it back
ctx.translate(-x6, -y6)
Spur(ctx).Gear(x6, y6, rp6, n6, pa, "black")
ctx.restore()

ctx.beginPath()
ctx.fillStyle = "#BA55D3"
ctx.font = "20px ScriptS"
ctx.fillText("40423117 ",x6-20, y6)
ctx.stroke()


# 將第7齒輪逆時鐘轉 90 度之後, 再往回轉第3齒輪定位帶動轉角, 然後再逆時鐘多轉一齒, 以便與第2齒輪進行囓合
ctx.save()
# translate to the origin of second gear
ctx.translate(x7, y7)
# rotate to engage
ctx.rotate(-math.pi/2-math.pi/n7+(math.pi+math.pi/n6)*n6/n7)
# put it back
ctx.translate(-x7, -y7)
Spur(ctx).Gear(x7, y7, rp7, n7, pa, "rad")
ctx.restore()

ctx.beginPath()
ctx.fillStyle = "#0000FF"
ctx.font = "20px ScriptS"
ctx.fillText("40423126 ",x7-20, y7)
ctx.stroke()

# 將第8齒輪逆時鐘轉 90 度之後, 再往回轉第3齒輪定位帶動轉角, 然後再逆時鐘多轉一齒, 以便與第2齒輪進行囓合
ctx.save()
# translate to the origin of second gear
ctx.translate(x8, y8)
# rotate to engage
ctx.rotate(-math.pi/2-math.pi/n8+(math.pi+math.pi/n7)*n7/n8*2)
# put it back
ctx.translate(-x8, -y8)
Spur(ctx).Gear(x8, y8, rp8, n8, pa, "purple")
ctx.restore()

ctx.beginPath()
ctx.fillStyle = "#BA55D3"
ctx.font = "20px ScriptS"
ctx.fillText("40423104 ",x8-20, y8)
ctx.stroke()

&lt;/script&gt;</summary><category term="正齒輪協同練習-W15"></category></entry><entry><title>W13-正齒輪齒數囓合繪圖</title><link href="./%E6%AD%A3%E9%BD%92%E8%BC%AA%E9%BD%92%E6%95%B8%E5%9B%93%E5%90%88%E7%B9%AA%E5%9C%96.html" rel="alternate"></link><published>2017-05-25T17:00:00+08:00</published><updated>2017-05-25T17:00:00+08:00</updated><author><name>40423104-YanSyuan</name></author><id>tag:,2017-05-25:./正齒輪齒數囓合繪圖.html</id><summary type="html">&lt;!-- PELICAN_END_SUMMARY --&gt;

&lt;!-- 導入 Brython 標準程式庫 --&gt;

&lt;script src="./../data/Brython-3.3.1/brython.js"&gt;&lt;/script&gt;

&lt;script src="./../data/Brython-3.3.1/brython_stdlib.js"&gt;&lt;/script&gt;

&lt;!-- 啟動 Brython --&gt;

&lt;script&gt;
window.onload=function(){
// 設定 data/py 為共用程式路徑
brython({debug:1, pythonpath:['./../data/py']});
}
&lt;/script&gt;

&lt;canvas id="onegear" width="800" height="600"&gt;&lt;/canvas&gt;

&lt;div id="onegear_div" width="800" height="20"&gt;&lt;/div&gt;

&lt;p&gt;&lt;input id="n1" value="13"&gt;&lt;/input&gt;&lt;br /&gt;
&lt;input id="n2" value="11"&gt;&lt;/input&gt;&lt;br /&gt;
&lt;input id="n3" value="17"&gt;&lt;/input&gt;&lt;br /&gt;
&lt;button id="button"&gt;Set Number of Gears&lt;/button&gt;&lt;/p&gt;

&lt;script type="text/python3"&gt;
from browser import document as doc
from browser import html
import math
# deg 為角度轉為徑度的轉換因子
deg = math.pi/180.
# 定義 Spur 類別
class Spur(object):
    def __init__(self, ctx):
        self.ctx = ctx

    def create_line(self, x1, y1, x2, y2, width=3, fill="red"):
        self.ctx.beginPath()
        self.ctx.lineWidth = width
        self.ctx.moveTo(x1, y1)
        self.ctx.lineTo(x2, y2)
        self.ctx.strokeStyle = fill
        self.ctx.stroke()
    #
    # 定義一個繪正齒輪的繪圖函式
    # midx 為齒輪圓心 x 座標
    # midy 為齒輪圓心 y 座標
    # rp 為節圓半徑, n 為齒數
    # pa 為壓力角 (deg)
    # 已經針對 n 大於等於 52 齒時的繪圖錯誤修正, 因為 base circle 與齒根圓大小必須進行判斷
    def Gear(self, midx, midy, rp, n=20, pa=20, color="black"):
        # 齒輪漸開線分成 15 線段繪製
        imax = 15
        # 在輸入的畫布上繪製直線, 由圓心到節圓 y 軸頂點畫一直線
        self.create_line(midx, midy, midx, midy-rp)
        # 畫出 rp 圓, 畫圓函式尚未定義
        #create_oval(midx-rp, midy-rp, midx+rp, midy+rp, width=2)
        # a 為模數 (代表公制中齒的大小), 模數為節圓直徑(稱為節徑)除以齒數
        # 模數也就是齒冠大小
        a=2*rp/n
        # d 為齒根大小, 為模數的 1.157 或 1.25倍, 這裡採 1.25 倍
        d=2.5*rp/n
        # ra 為齒輪的外圍半徑
        ra=rp+a
        # 畫出 ra 圓, 畫圓函式尚未定義
        #create_oval(midx-ra, midy-ra, midx+ra, midy+ra, width=1)
        # rb 則為齒輪的基圓半徑
        # 基圓為漸開線長齒之基準圓
        rb=rp*math.cos(pa*deg)
        # 畫出 rb 圓 (基圓), 畫圓函式尚未定義
        #create_oval(midx-rb, midy-rb, midx+rb, midy+rb, width=1)
        # rd 為齒根圓半徑
        rd=rp-d
        # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd
        # 畫出 rd 圓 (齒根圓), 畫圓函式尚未定義
        #create_oval(midx-rd, midy-rd, midx+rd, midy+rd, width=1)
        # dr 則為基圓到齒頂圓半徑分成 imax 段後的每段半徑增量大小
        # 將圓弧分成 imax 段來繪製漸開線
        # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd
        if rd&gt;rb:
            dr = (ra-rd)/imax
        else:
            dr=(ra-rb)/imax
        # tan(pa*deg)-pa*deg 為漸開線函數
        sigma=math.pi/(2*n)+math.tan(pa*deg)-pa*deg
        for j in range(n):
            ang=-2.*j*math.pi/n+sigma
            ang2=2.*j*math.pi/n+sigma
            lxd=midx+rd*math.sin(ang2-2.*math.pi/n)
            lyd=midy-rd*math.cos(ang2-2.*math.pi/n)
            for i in range(imax+1):
                # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd
                if rd&gt;rb:
                    r=rd+i*dr
                else:
                    r=rb+i*dr
                theta=math.sqrt((r*r)/(rb*rb)-1.)
                alpha=theta-math.atan(theta)
                xpt=r*math.sin(alpha-ang)
                ypt=r*math.cos(alpha-ang)
                xd=rd*math.sin(-ang)
                yd=rd*math.cos(-ang)
                # i=0 時, 繪線起點由齒根圓上的點, 作為起點
                if(i==0):
                    last_x = midx+xd
                    last_y = midy-yd
                # 由左側齒根圓作為起點, 除第一點 (xd,yd) 齒根圓上的起點外, 其餘的 (xpt,ypt)則為漸開線上的分段點
                self.create_line((midx+xpt),(midy-ypt),(last_x),(last_y),fill=color)
                # 最後一點, 則為齒頂圓
                if(i==imax):
                    lfx=midx+xpt
                    lfy=midy-ypt
                last_x = midx+xpt
                last_y = midy-ypt
            # the line from last end of dedendum point to the recent
            # end of dedendum point
            # lxd 為齒根圓上的左側 x 座標, lyd 則為 y 座標
            # 下列為齒根圓上用來近似圓弧的直線
            self.create_line((lxd),(lyd),(midx+xd),(midy-yd),fill=color)
            for i in range(imax+1):
                # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd
                if rd&gt;rb:
                    r=rd+i*dr
                else:
                    r=rb+i*dr
                theta=math.sqrt((r*r)/(rb*rb)-1.)
                alpha=theta-math.atan(theta)
                xpt=r*math.sin(ang2-alpha)
                ypt=r*math.cos(ang2-alpha)
                xd=rd*math.sin(ang2)
                yd=rd*math.cos(ang2)
                # i=0 時, 繪線起點由齒根圓上的點, 作為起點
                if(i==0):
                    last_x = midx+xd
                    last_y = midy-yd
                # 由右側齒根圓作為起點, 除第一點 (xd,yd) 齒根圓上的起點外, 其餘的 (xpt,ypt)則為漸開線上的分段點
                self.create_line((midx+xpt),(midy-ypt),(last_x),(last_y),fill=color)
                # 最後一點, 則為齒頂圓
                if(i==imax):
                    rfx=midx+xpt
                    rfy=midy-ypt
                last_x = midx+xpt
                last_y = midy-ypt
            # lfx 為齒頂圓上的左側 x 座標, lfy 則為 y 座標
            # 下列為齒頂圓上用來近似圓弧的直線
            self.create_line(lfx,lfy,rfx,rfy,fill=color)

canvas = doc['onegear']
ctx = canvas.getContext("2d")

# 以 button 驅動的事件函式
def setgearnumber(e):
    ctx.clearRect(0, 0, canvas.width, canvas.height)
    x = (canvas.width)/2
    y = (canvas.height)/2
    if doc["n1"].value.isdigit():
        n17 = int(doc["n1"].value)
    else:
        n17 = 17

    if doc["n2"].value.isdigit():
        n11 = int(doc["n2"].value)
    else:
        n11 = 11

    if doc["n3"].value.isdigit():
        n13 = int(doc["n3"].value)
    else:
        n13 = 13

    # 只使用畫布高度的 80%
    canvas_size = canvas.height*0.4
    r17 = canvas_size*n17/(n17+n11+n13)
    r11 = canvas_size*n11/(n17+n11+n13)
    r13 = canvas_size*n13/(n17+n11+n13)
    # 計算各齒輪中心座標
    x17 = x - r17-r11
    y17 = y

    x11 = x 
    y11 = y

    x13 = x + r11+r13
    y13 = y

    pa = 20
    # 開始繪製齒輪
    # 儲存原有的座標系統
    ctx.save()
    # 平移到齒輪圓心
    ctx.translate(x17, y17)
    # 以齒輪圓心旋轉 90 度, 讓紅色標線在齒輪右側保持水平
    ctx.rotate(90*deg)
    # 平移回原來的座標原點
    ctx.translate(-x17, -y17)
    gear17 = Spur(ctx).Gear(x17, y17, r17, n17, pa, "blue")
    # 回復原有的座標系統
    ctx.restore()

    ctx.save()
    ctx.translate(x11, y11)
    # 中間齒輪轉動 -90 度加上一齒, 可以與左側齒輪囓合
    ctx.rotate(-90*deg-math.pi/n11)
    ctx.translate(-x11, -y11)
    gear11 = Spur(ctx).Gear(x11, y11, r11, n11, pa, "blue")
    ctx.restore()

    ctx.save()
    ctx.translate(x13, y13)
    # 右側齒輪轉動 -90 度加上一齒, 可以與原來標線在左側水平的中間齒輪囓合, 但是目前中間齒輪的標線已經轉了 180 度加或減一次
    # 必須配合兩齒的速比轉換旋轉角, 以便讓中間齒輪與右側齒輪囓合
    ctx.rotate(-90*deg-math.pi/n13+(180*deg+math.pi/n11)*n11/n13)
    ctx.translate(-x13, -y13)
    gear13 = Spur(ctx).Gear(x13, y13, r13, n13, pa, "blue")
    ctx.restore()

setgearnumber(True)

'''
div = doc["onegear_div"]
form = html.FORM()
input1 = html.INPUT(type="text", id="n1", name="n1", value="13")
input2 = html.INPUT(type="text", id="n2", name="n2", value="11")
input3 = html.INPUT(type="text", id="n3", name="n3", value="19")
div &lt;= input1 + html.BR() + input2 + html.BR() + input3
'''
doc['button'].bind('click',setgearnumber)
&lt;/script&gt;</summary><category term="正齒輪齒數囓合繪圖-W13"></category></entry><entry><title>W12-2D與3D傳動正齒輪</title><link href="./2D%E8%88%873D%E5%82%B3%E5%8B%95%E6%AD%A3%E9%BD%92%E8%BC%AA.html" rel="alternate"></link><published>2017-05-18T17:00:00+08:00</published><updated>2017-05-18T17:00:00+08:00</updated><author><name>40423104-YanSyuan</name></author><id>tag:,2017-05-18:./2D與3D傳動正齒輪.html</id><summary type="html">&lt;h4&gt;為何需要減速機?何謂漸開線?如何畫漸開線正齒輪輪廓?如何模擬 2D 正齒輪組囓合？如何模擬 3D 正齒輪組囓合？如何將齒輪減速機構納入四足行走機構?如何以 2D 動畫模擬齒輪囓合傳動?如何以 3D 動畫模擬齒輪囓合傳動?如何模擬四足機構行走?如何列印齒輪組零件?如何列印連桿機構?如何組立齒輪組與行走機構?如何控制馬達?&lt;/h4&gt;
&lt;h3&gt;3個正齒輪固定齒數囓合繪圖&lt;/h3&gt;
&lt;h3&gt;寫成 Fossil SCM 網頁互動式&lt;/h3&gt;


&lt;h3&gt;1.為何需要減速機?&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;降速同時提高輸出扭矩，扭矩輸出比例按電機輸出乘減速比，但要注意不能超出減速機額定扭矩。&lt;/li&gt;
&lt;li&gt;速同時降低了負載的慣量，慣量的減少為減速比的平方。 &lt;/li&gt;
&lt;li&gt;減速機是一種相對精密的機械，使用它的目的是降低轉速，增加轉矩。&lt;/li&gt;
&lt;li&gt;利用各級齒輪傳動來達到降速的目的.減速器就是由各級齒輪副組成的.比如用小齒輪帶動大齒輪就能達到一定的減速的目的&lt;/li&gt;
&lt;li&gt;減速機是一種動力傳達機構，利用齒輪的速度轉換器，將馬達的回轉數減速到所要的回轉數，並得到較大轉矩的機構。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;何謂漸開線?&lt;/h3&gt;
&lt;p&gt;假如將一條線繞著一個多邊形， 一頭固定，一頭向外拉開，則拉開的這個線頭所走的軌跡，就是漸開線。
亦可為繞於一多邊形或圓形之緊索上之一點，該點向外伸開時所形成之軌跡。&lt;/p&gt;
&lt;h3&gt;如何畫漸開線正齒輪輪廓?&lt;/h3&gt;
&lt;p&gt;自訂模數、齒數、壓力角，利用程式繪製節圓、齒頂圓、齒根圓及基圓等
&lt;!-- 導入 Brython 標準程式庫 --&gt;&lt;/p&gt;
&lt;script src="../data/Brython-3.3.1/brython.js"&gt;&lt;/script&gt;

&lt;script src="../data/Brython-3.3.1/brython_stdlib.js"&gt;&lt;/script&gt;

&lt;!-- 以下實際利用  Brython 繪圖--&gt;

&lt;canvas id="onegear1" width="800" height="600"&gt;&lt;/canvas&gt;

&lt;div id="onegear1_div" width="800" height="20"&gt;&lt;/div&gt;

&lt;script type="text/python3"&gt;
from browser import document as doc
import math
# deg 為角度轉為徑度的轉換因子
deg = math.pi/180.
# 定義 Spur 類別
class Spur(object):
    def __init__(self, ctx):
        self.ctx = ctx

    def create_line(self, x1, y1, x2, y2, width=3, fill="red"):
        self.ctx.beginPath()
        self.ctx.lineWidth = width
        self.ctx.moveTo(x1, y1)
        self.ctx.lineTo(x2, y2)
        self.ctx.strokeStyle = fill
        self.ctx.stroke()
    #
    # 定義一個繪正齒輪的繪圖函式
    # midx 為齒輪圓心 x 座標
    # midy 為齒輪圓心 y 座標
    # rp 為節圓半徑, n 為齒數
    # pa 為壓力角 (deg)
    # rot 為旋轉角 (deg)
    # 已經針對 n 大於等於 52 齒時的繪圖錯誤修正, 因為 base circle 與齒根圓大小必須進行判斷
    def Gear(self, midx, midy, rp, n=20, pa=20, color="black"):
        # 齒輪漸開線分成 15 線段繪製
        imax = 15
        # 在輸入的畫布上繪製直線, 由圓心到節圓 y 軸頂點畫一直線
        self.create_line(midx, midy, midx, midy-rp)
        # 畫出 rp 圓, 畫圓函式尚未定義
        #create_oval(midx-rp, midy-rp, midx+rp, midy+rp, width=2)
        # a 為模數 (代表公制中齒的大小), 模數為節圓直徑(稱為節徑)除以齒數
        # 模數也就是齒冠大小
        a=2*rp/n
        # d 為齒根大小, 為模數的 1.157 或 1.25倍, 這裡採 1.25 倍
        d=2.5*rp/n
        # ra 為齒輪的外圍半徑
        ra=rp+a
        # 畫出 ra 圓, 畫圓函式尚未定義
        #create_oval(midx-ra, midy-ra, midx+ra, midy+ra, width=1)
        # rb 則為齒輪的基圓半徑
        # 基圓為漸開線長齒之基準圓
        rb=rp*math.cos(pa*deg)
        # 畫出 rb 圓 (基圓), 畫圓函式尚未定義
        #create_oval(midx-rb, midy-rb, midx+rb, midy+rb, width=1)
        # rd 為齒根圓半徑
        rd=rp-d
        # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd
        # 畫出 rd 圓 (齒根圓), 畫圓函式尚未定義
        #create_oval(midx-rd, midy-rd, midx+rd, midy+rd, width=1)
        # dr 則為基圓到齒頂圓半徑分成 imax 段後的每段半徑增量大小
        # 將圓弧分成 imax 段來繪製漸開線
        # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd
        if rd&gt;rb:
            dr = (ra-rd)/imax
        else:
            dr=(ra-rb)/imax
        # tan(pa*deg)-pa*deg 為漸開線函數
        sigma=math.pi/(2*n)+math.tan(pa*deg)-pa*deg
        for j in range(n):
            ang=-2.*j*math.pi/n+sigma
            ang2=2.*j*math.pi/n+sigma
            lxd=midx+rd*math.sin(ang2-2.*math.pi/n)
            lyd=midy-rd*math.cos(ang2-2.*math.pi/n)
            for i in range(imax+1):
                # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd
                if rd&gt;rb:
                    r=rd+i*dr
                else:
                    r=rb+i*dr
                theta=math.sqrt((r*r)/(rb*rb)-1.)
                alpha=theta-math.atan(theta)
                xpt=r*math.sin(alpha-ang)
                ypt=r*math.cos(alpha-ang)
                xd=rd*math.sin(-ang)
                yd=rd*math.cos(-ang)
                # i=0 時, 繪線起點由齒根圓上的點, 作為起點
                if(i==0):
                    last_x = midx+xd
                    last_y = midy-yd
                # 由左側齒根圓作為起點, 除第一點 (xd,yd) 齒根圓上的起點外, 其餘的 (xpt,ypt)則為漸開線上的分段點
                self.create_line((midx+xpt),(midy-ypt),(last_x),(last_y),fill=color)
                # 最後一點, 則為齒頂圓
                if(i==imax):
                    lfx=midx+xpt
                    lfy=midy-ypt
                last_x = midx+xpt
                last_y = midy-ypt
            # the line from last end of dedendum point to the recent
            # end of dedendum point
            # lxd 為齒根圓上的左側 x 座標, lyd 則為 y 座標
            # 下列為齒根圓上用來近似圓弧的直線
            self.create_line((lxd),(lyd),(midx+xd),(midy-yd),fill=color)
            for i in range(imax+1):
                # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd
                if rd&gt;rb:
                    r=rd+i*dr
                else:
                    r=rb+i*dr
                theta=math.sqrt((r*r)/(rb*rb)-1.)
                alpha=theta-math.atan(theta)
                xpt=r*math.sin(ang2-alpha)
                ypt=r*math.cos(ang2-alpha)
                xd=rd*math.sin(ang2)
                yd=rd*math.cos(ang2)
                # i=0 時, 繪線起點由齒根圓上的點, 作為起點
                if(i==0):
                    last_x = midx+xd
                    last_y = midy-yd
                # 由右側齒根圓作為起點, 除第一點 (xd,yd) 齒根圓上的起點外, 其餘的 (xpt,ypt)則為漸開線上的分段點
                self.create_line((midx+xpt),(midy-ypt),(last_x),(last_y),fill=color)
                # 最後一點, 則為齒頂圓
                if(i==imax):
                    rfx=midx+xpt
                    rfy=midy-ypt
                last_x = midx+xpt
                last_y = midy-ypt
            # lfx 為齒頂圓上的左側 x 座標, lfy 則為 y 座標
            # 下列為齒頂圓上用來近似圓弧的直線
            self.create_line(lfx,lfy,rfx,rfy,fill=color)
canvas = doc['onegear1']
ctx = canvas.getContext("2d")
x = (canvas.width)/2
y = (canvas.height)/2
r = 0.8*(canvas.height/2)
# 齒數
n = 15
# 壓力角
pa = 20
Spur(ctx).Gear(x, y, r, n, pa, "black")
&lt;/script&gt;

&lt;h3&gt;如何模擬 2D 正齒輪組囓合？&lt;/h3&gt;
&lt;!-- 導入 Brython 標準程式庫 --&gt;

&lt;script src="../data/Brython-3.3.1/brython.js"&gt;&lt;/script&gt;

&lt;script src="../data/Brython-3.3.1/brython_stdlib.js"&gt;&lt;/script&gt;

&lt;!-- 啟動 Brython --&gt;

&lt;script&gt;
window.onload=function(){
// 設定 data/py 為共用程式路徑
brython({debug:1, pythonpath:['./../data/py']});
}
&lt;/script&gt;

&lt;!-- 以下實際利用  Brython 繪圖--&gt;

&lt;canvas id="gear1" width="600" height="600"&gt;&lt;/canvas&gt;

&lt;div id="gear1_div" width="800" height="20"&gt;&lt;/div&gt;

&lt;script type="text/python3"&gt;
from browser import document as doc
import math
# deg 為角度轉為徑度的轉換因子
deg = math.pi/180.
# 定義 Spur 類別
class Spur(object):
    def __init__(self, ctx):
        self.ctx = ctx

    def create_line(self, x1, y1, x2, y2, width=3, fill="red"):
        self.ctx.beginPath()
        self.ctx.lineWidth = width
        self.ctx.moveTo(x1, y1)
        self.ctx.lineTo(x2, y2)
        self.ctx.strokeStyle = fill
        self.ctx.stroke()
    #
    # 定義一個繪正齒輪的繪圖函式
    # midx 為齒輪圓心 x 座標
    # midy 為齒輪圓心 y 座標
    # rp 為節圓半徑, n 為齒數
    # pa 為壓力角 (deg)
    # rot 為旋轉角 (deg)
    # 已經針對 n 大於等於 52 齒時的繪圖錯誤修正, 因為 base circle 與齒根圓大小必須進行判斷
    def Gear(self, midx, midy, rp, n=17, pa=20, color="black"):
        # 齒輪漸開線分成 15 線段繪製
        imax = 15
        # 在輸入的畫布上繪製直線, 由圓心到節圓 y 軸頂點畫一直線
        self.create_line(midx, midy, midx, midy-rp)
        # 畫出 rp 圓, 畫圓函式尚未定義
        #create_oval(midx-rp, midy-rp, midx+rp, midy+rp, width=2)
        # a 為模數 (代表公制中齒的大小), 模數為節圓直徑(稱為節徑)除以齒數
        # 模數也就是齒冠大小
        a=2*rp/n
        # d 為齒根大小, 為模數的 1.157 或 1.25倍, 這裡採 1.25 倍
        d=2.5*rp/n
        # ra 為齒輪的外圍半徑
        ra=rp+a
        # 畫出 ra 圓, 畫圓函式尚未定義
        #create_oval(midx-ra, midy-ra, midx+ra, midy+ra, width=1)
        # rb 則為齒輪的基圓半徑
        # 基圓為漸開線長齒之基準圓
        rb=rp*math.cos(pa*deg)
        # 畫出 rb 圓 (基圓), 畫圓函式尚未定義
        #create_oval(midx-rb, midy-rb, midx+rb, midy+rb, width=1)
        # rd 為齒根圓半徑
        rd=rp-d
        # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd
        # 畫出 rd 圓 (齒根圓), 畫圓函式尚未定義
        #create_oval(midx-rd, midy-rd, midx+rd, midy+rd, width=1)
        # dr 則為基圓到齒頂圓半徑分成 imax 段後的每段半徑增量大小
        # 將圓弧分成 imax 段來繪製漸開線
        # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd
        if rd&gt;rb:
            dr = (ra-rd)/imax
        else:
            dr=(ra-rb)/imax
        # tan(pa*deg)-pa*deg 為漸開線函數
        sigma=math.pi/(2*n)+math.tan(pa*deg)-pa*deg
        for j in range(n):
            ang=-2.*j*math.pi/n+sigma
            ang2=2.*j*math.pi/n+sigma
            lxd=midx+rd*math.sin(ang2-2.*math.pi/n)
            lyd=midy-rd*math.cos(ang2-2.*math.pi/n)
            for i in range(imax+1):
                # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd
                if rd&gt;rb:
                    r=rd+i*dr
                else:
                    r=rb+i*dr
                theta=math.sqrt((r*r)/(rb*rb)-1.)
                alpha=theta-math.atan(theta)
                xpt=r*math.sin(alpha-ang)
                ypt=r*math.cos(alpha-ang)
                xd=rd*math.sin(-ang)
                yd=rd*math.cos(-ang)
                # i=0 時, 繪線起點由齒根圓上的點, 作為起點
                if(i==0):
                    last_x = midx+xd
                    last_y = midy-yd
                # 由左側齒根圓作為起點, 除第一點 (xd,yd) 齒根圓上的起點外, 其餘的 (xpt,ypt)則為漸開線上的分段點
                self.create_line((midx+xpt),(midy-ypt),(last_x),(last_y),fill=color)
                # 最後一點, 則為齒頂圓
                if(i==imax):
                    lfx=midx+xpt
                    lfy=midy-ypt
                last_x = midx+xpt
                last_y = midy-ypt
            # the line from last end of dedendum point to the recent
            # end of dedendum point
            # lxd 為齒根圓上的左側 x 座標, lyd 則為 y 座標
            # 下列為齒根圓上用來近似圓弧的直線
            self.create_line((lxd),(lyd),(midx+xd),(midy-yd),fill=color)
            for i in range(imax+1):
                # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd
                if rd&gt;rb:
                    r=rd+i*dr

                else:
                    r=rb+i*dr
                theta=math.sqrt((r*r)/(rb*rb)-1.)
                alpha=theta-math.atan(theta)
                xpt=r*math.sin(ang2-alpha)
                ypt=r*math.cos(ang2-alpha)
                xd=rd*math.sin(ang2)
                yd=rd*math.cos(ang2)
                # i=0 時, 繪線起點由齒根圓上的點, 作為起點
                if(i==0):
                    last_x = midx+xd
                    last_y = midy-yd
                # 由右側齒根圓作為起點, 除第一點 (xd,yd) 齒根圓上的起點外, 其餘的 (xpt,ypt)則為漸開線上的分段點
                self.create_line((midx+xpt),(midy-ypt),(last_x),(last_y),fill=color)
                # 最後一點, 則為齒頂圓
                if(i==imax):
                    rfx=midx+xpt
                    rfy=midy-ypt
                last_x = midx+xpt
                last_y = midy-ypt
            # lfx 為齒頂圓上的左側 x 座標, lfy 則為 y 座標
            # 下列為齒頂圓上用來近似圓弧的直線
            self.create_line(lfx,lfy,rfx,rfy,fill=color)

canvas = doc['gear1']
ctx = canvas.getContext("2d")
x = (canvas.width)/2
y = (canvas.height)/2
r = 0.8*(canvas.height/2)
m = (0.8*canvas.width)/(n17+n11+n13)
# 齒數
n17 = 17
n11 = 11
n13 = 13
canvas_size = canvas.height*0.4
r17 = m* n17/2
r11 = m* n11/2
r13 = m* n13/2
x17 = canvas.width*0.1+r17
y17 = canvas.height*0.2+r17
x11 = x17 + r17 + r11
y11 = y17
x13 = x17 + r17 + 2*r11 + r13
y13 = y17
# 壓力角
pa = 20

ctx.save()
ctx.translate(x17, y17)
ctx.rotate(math.pi/2)
ctx.translate(-x17, -y17)
Spur(ctx).Gear(x17, y17, r17, n17, pa, "blue")
ctx.restore()

ctx.save()
ctx.translate(x11, y11)
ctx.rotate(-math.pi/2-math.pi/n11)
ctx.translate(-x11, -y11)
Spur(ctx).Gear(x11, y11, r11, n11, pa, "red")
ctx.restore()

ctx.save()
ctx.translate(x13, y13)
ctx.rotate(-math.pi/2-math.pi/n13+(math.pi+math.pi/n11)*n11/n13)
ctx.translate(-x13, -y13)
Spur(ctx).Gear(x13, y13, r13, n13, pa, "black")
ctx.restore()

div = doc["onegear1_div"]

&lt;/script&gt;

&lt;h3&gt;如何模擬 3D 正齒輪組囓合？&lt;/h3&gt;
&lt;p&gt;利用onshape繪製多個齒輪，再進行組裝模擬。&lt;/p&gt;
&lt;h5&gt;齒輪繪製&lt;/h5&gt;
&lt;p&gt;&lt;iframe src="https://player.vimeo.com/video/220592224" width="640" height="342" frameborder="0" webkitallowfullscreen mozallowfullscreen allowfullscreen&gt;&lt;/iframe&gt;
&lt;p&gt;&lt;a href="https://vimeo.com/220592224"&gt;虎尾科技大學 機械設計工程系-40423104-W12-3D gear模擬-所有零件繪製&lt;/a&gt; from &lt;a href="https://vimeo.com/user44900188"&gt;40423104-Yan syuan&lt;/a&gt; on &lt;a href="https://vimeo.com"&gt;Vimeo&lt;/a&gt;.&lt;/p&gt;&lt;/p&gt;
&lt;h5&gt;齒輪組裝模擬&lt;/h5&gt;
&lt;p&gt;&lt;iframe src="https://player.vimeo.com/video/220593953" width="640" height="342" frameborder="0" webkitallowfullscreen mozallowfullscreen allowfullscreen&gt;&lt;/iframe&gt;
&lt;p&gt;&lt;a href="https://vimeo.com/220593953"&gt;虎尾科技大學 機械設計工程系-40423104-W12-3D gear組合模擬&lt;/a&gt; from &lt;a href="https://vimeo.com/user44900188"&gt;40423104-Yan syuan&lt;/a&gt; on &lt;a href="https://vimeo.com"&gt;Vimeo&lt;/a&gt;.&lt;/p&gt;&lt;/p&gt;
&lt;p&gt;如何將齒輪減速機構納入四足行走機構?&lt;/p&gt;
&lt;p&gt;如何以 2D 動畫模擬齒輪囓合傳動?
&lt;!-- 以下處理 Cango Spur Gear --&gt;&lt;/p&gt;
&lt;!-- Cango 程式庫 --&gt;

&lt;script type="text/javascript" src="./../data/w11/cango
/Cango-9v05-min.js"&gt;&lt;/script&gt;

&lt;script type="text/javascript" src="./../data/w11/cango
/CangoAxes-2v09.js"&gt;&lt;/script&gt;

&lt;script type="text/javascript" src="./../data/w11/cango
/CangoAnimation-5v00.js"&gt;&lt;/script&gt;

&lt;script type="text/javascript" src="./../data/w11/cango
/gearUtils-05.js"&gt;&lt;/script&gt;

&lt;canvas id='cango_gear' width='800' height='750'&gt;&lt;/canvas&gt;

&lt;script type="text/python"&gt;
# 將 導入的 document 設為 doc 主要原因在於與舊程式碼相容
from browser import document as doc
# 由於 Python3 與 Javascript 程式碼已經不再混用, 因此來自 Javascript 的變數, 必須居中透過 window 物件轉換
from browser import window
import math

# 主要用來取得畫布大小
canvas = doc["cango_gear"]
# 此程式採用 Cango Javascript 程式庫繪圖, 因此無需 ctx
ctx = canvas.getContext("2d")
cango = window.Cango.new
# 針對變數的轉換, shapeDefs 在 Cango 中資料型別為變數, 可以透過 window 轉換
shapedefs = window.shapeDefs
# 目前 Cango 結合 Animation 在 Brython 尚無法運作, 此刻只能繪製靜態圖形
# in CangoAnimation.js
#interpolate1 = window.interpolate
# Cobi 與 createGearTooth 都是 Cango Javascript 程式庫中的物件
#cobj = window.Cobj.new
shape = window.Shape.new
path = window.Path.new
creategeartooth = window.createGearTooth.new

tweener = window.Tweener.new
# 經由 Cango 轉換成 Brython 的 cango, 指定將圖畫在 id="cango_gear" 的 canvas 上
cgo = cango("cango_gear")

######################################
# 畫正齒輪輪廓
#####################################
# n 為齒數
n = 17
# pa 為壓力角
pa = 25
# m 為模數, 根據畫布的寬度, 計算適合的模數大小
# Module = mm of pitch diameter per tooth
m = 0.8*canvas.width/n
# pr 為節圓半徑
pr = n*m/2 # gear Pitch radius
# generate gear
data = creategeartooth(m, n, pa)
# Brython 程式中的 print 會將資料印在 Browser 的 console 區
#print(data)
gearTooth = shape(data, {
  "fillColor":"#ddd0dd",
  "border": True,
  "strokeColor": "#606060" })
gearTooth.rotate(180/n) # rotate gear 1/2 tooth to mesh
# 單齒的齒形資料經過旋轉後, 將資料複製到 gear 物件中
gear = gearTooth.dup()
# gear 為單一齒的輪廓資料
#cgo.render(gearTooth)

# 利用單齒輪廓旋轉, 產生整個正齒輪外形
for i in range(1, n):
    # 將 gearTooth 中的資料複製到 newTooth
    newTooth = gearTooth.dup()
    # 配合迴圈, newTooth 的齒形資料進行旋轉, 然後利用 appendPath 方法, 將資料併入 gear
    newTooth.rotate(360*i/n)
    # appendPath 為 Cango 程式庫中的方法, 第二個變數為 True, 表示要刪除最前頭的 Move to SVG Path 標註符號
    gear.appendPath(newTooth, True) # trim move command = True

# 建立軸孔
# add axle hole, hr 為 hole radius
hr = 0.6*pr # diameter of gear shaft
shaft = path(shapedefs.circle(hr))
shaft.revWinding()
gear.appendPath(shaft) # retain the 'moveTo' command for shaft sub path

# setup the animation
# backlash (mm)
bklsh = 0.04*m
# centre shift to make backlash
dC = bklsh/(2*math.tan(math.pi*pa/180))
# np 為小齒輪齒數
np = 13
# gear ratio
gr = n/np              
gearConfig = {'cx':-pr, 'cy':0, 'degs':[0, 360]}
# gr*0.666 rpm
#pinionConfig = {'cx':pr+dC, 'cy':0, 'degs':[0, -gr*360]}
# 0.666 rpm
twnr = tweener(0, 90000, "loop")

cx = canvas.width/2
cy = canvas.height/2
#gear.translate(cx, cy)
# render 繪出靜態正齒輪輪廓
#cgo.render(gear)
# 利用 gear 資料複製一份, 命名為 gear1
gear1 = gear.dup()

from time import time
from browser.timer import request_animation_frame as raf
from browser.timer import set_interval

deg = math.pi/180

def draw():
    cgo.clearCanvas()
    gear.rotate(2*deg)
    # 在特定位置, 以特定 scale, 特定 degs 執行 render
    cgo.render(gear, {'x':cx-pr/2, 'y':cy, 'scl':0.5, 'degs':0})
    gear1.rotate(-2*deg)
    cgo.render(gear1, {'x':cx+pr*2*0.5-pr/2, 'y':cy, 'scl':0.5, 'degs':0})

set_interval(draw, 2)
&lt;/script&gt;

&lt;h3&gt;如何以 3D 動畫模擬齒輪囓合傳動?&lt;/h3&gt;
&lt;p&gt;&lt;iframe src="https://player.vimeo.com/video/220595383" width="640" height="342" frameborder="0" webkitallowfullscreen mozallowfullscreen allowfullscreen&gt;&lt;/iframe&gt;
&lt;p&gt;&lt;a href="https://vimeo.com/220595383"&gt;虎尾科技大學 機械設計工程系-40423104-W12-3D 動畫模擬齒輪&lt;/a&gt; from &lt;a href="https://vimeo.com/user44900188"&gt;40423104-Yan syuan&lt;/a&gt; on &lt;a href="https://vimeo.com"&gt;Vimeo&lt;/a&gt;.&lt;/p&gt;&lt;/p&gt;
&lt;p&gt;如何模擬四足機構行走?&lt;/p&gt;
&lt;p&gt;如何列印齒輪組零件?&lt;/p&gt;
&lt;p&gt;如何列印連桿機構?&lt;/p&gt;
&lt;p&gt;如何組立齒輪組與行走機構?&lt;/p&gt;
&lt;p&gt;如何控制馬達?&lt;/p&gt;
&lt;p&gt;http://www.engineering.com/DesignSoftware/DesignSoftwareArticles/ArticleID/14856/One-Company-Needs-to-Buy-OnshapeHeres-Why.aspx&lt;/p&gt;
&lt;p&gt;3個正齒輪固定齒數囓合繪圖
&lt;!-- 導入 Brython 標準程式庫 --&gt;&lt;/p&gt;
&lt;script src="../data/Brython-3.3.1/brython.js"&gt;&lt;/script&gt;

&lt;script src="../data/Brython-3.3.1/brython_stdlib.js"&gt;&lt;/script&gt;

&lt;!-- 啟動 Brython --&gt;

&lt;script&gt;
window.onload=function(){
// 設定 data/py 為共用程式路徑
brython({debug:1, pythonpath:['./../data/py']});
}
&lt;/script&gt;

&lt;!-- 以下實際利用  Brython 繪圖--&gt;

&lt;canvas id="gear2" width="800" height="600"&gt;&lt;/canvas&gt;

&lt;div id="gear2_div" width="800" height="20"&gt;&lt;/div&gt;

&lt;script type="text/python3"&gt;
from browser import document as doc
import math
# deg 為角度轉為徑度的轉換因子
deg = math.pi/180.
# 定義 Spur 類別
class Spur(object):
    def __init__(self, ctx):
        self.ctx = ctx

    def create_line(self, x1, y1, x2, y2, width=3, fill="red"):
        self.ctx.beginPath()
        self.ctx.lineWidth = width
        self.ctx.moveTo(x1, y1)
        self.ctx.lineTo(x2, y2)
        self.ctx.strokeStyle = fill
        self.ctx.stroke()
    #
    # 定義一個繪正齒輪的繪圖函式
    # midx 為齒輪圓心 x 座標
    # midy 為齒輪圓心 y 座標
    # rp 為節圓半徑, n 為齒數
    # pa 為壓力角 (deg)
    # rot 為旋轉角 (deg)
    # 已經針對 n 大於等於 52 齒時的繪圖錯誤修正, 因為 base circle 與齒根圓大小必須進行判斷
    def Gear(self, midx, midy, rp, n=20, pa=20, color="black", rot):
        # 齒輪漸開線分成 15 線段繪製
        imax = 15
        # 在輸入的畫布上繪製直線, 由圓心到節圓 y 軸頂點畫一直線
        self.create_line(midx, midy, midx, midy-rp)
        # 畫出 rp 圓, 畫圓函式尚未定義
        #create_oval(midx-rp, midy-rp, midx+rp, midy+rp, width=2)
        # a 為模數 (代表公制中齒的大小), 模數為節圓直徑(稱為節徑)除以齒數
        # 模數也就是齒冠大小
        a=2*rp/n
        # d 為齒根大小, 為模數的 1.157 或 1.25倍, 這裡採 1.25 倍
        d=2.5*rp/n
        # ra 為齒輪的外圍半徑
        ra=rp+a
        # 畫出 ra 圓, 畫圓函式尚未定義
        #create_oval(midx-ra, midy-ra, midx+ra, midy+ra, width=1)
        # rb 則為齒輪的基圓半徑
        # 基圓為漸開線長齒之基準圓
        rb=rp*math.cos(pa*deg)
        # 畫出 rb 圓 (基圓), 畫圓函式尚未定義
        #create_oval(midx-rb, midy-rb, midx+rb, midy+rb, width=1)
        # rd 為齒根圓半徑
        rd=rp-d
        # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd
        # 畫出 rd 圓 (齒根圓), 畫圓函式尚未定義
        #create_oval(midx-rd, midy-rd, midx+rd, midy+rd, width=1)
        # dr 則為基圓到齒頂圓半徑分成 imax 段後的每段半徑增量大小
        # 將圓弧分成 imax 段來繪製漸開線
        # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd
        if rd&gt;rb:
            dr = (ra-rd)/imax
        else:
            dr=(ra-rb)/imax
        # tan(pa*deg)-pa*deg 為漸開線函數
        sigma=math.pi/(2*n)+math.tan(pa*deg)-pa*deg
        for j in range(n):
            ang=-2.*j*math.pi/n+sigma
            ang2=2.*j*math.pi/n+sigma
            lxd=midx+rd*math.sin(ang2-2.*math.pi/n)
            lyd=midy-rd*math.cos(ang2-2.*math.pi/n)
            for i in range(imax+1):
                # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd
                if rd&gt;rb:
                    r=rd+i*dr
                else:
                    r=rb+i*dr
                theta=math.sqrt((r*r)/(rb*rb)-1.)
                alpha=theta-math.atan(theta)
                xpt=r*math.sin(alpha-ang)
                ypt=r*math.cos(alpha-ang)
                xd=rd*math.sin(-ang)
                yd=rd*math.cos(-ang)
                # i=0 時, 繪線起點由齒根圓上的點, 作為起點
                if(i==0):
                    last_x = midx+xd
                    last_y = midy-yd
                # 由左側齒根圓作為起點, 除第一點 (xd,yd) 齒根圓上的起點外, 其餘的 (xpt,ypt)則為漸開線上的分段點
                self.create_line((midx+xpt),(midy-ypt),(last_x),(last_y),fill=color)
                # 最後一點, 則為齒頂圓
                if(i==imax):
                    lfx=midx+xpt
                    lfy=midy-ypt
                last_x = midx+xpt
                last_y = midy-ypt
            # the line from last end of dedendum point to the recent
            # end of dedendum point
            # lxd 為齒根圓上的左側 x 座標, lyd 則為 y 座標
            # 下列為齒根圓上用來近似圓弧的直線
            self.create_line((lxd),(lyd),(midx+xd),(midy-yd),fill=color)
            for i in range(imax+1):
                # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd
                if rd&gt;rb:
                    r=rd+i*dr
                else:
                    r=rb+i*dr
                theta=math.sqrt((r*r)/(rb*rb)-1.)
                alpha=theta-math.atan(theta)
                xpt=r*math.sin(ang2-alpha)
                ypt=r*math.cos(ang2-alpha)
                xd=rd*math.sin(ang2)
                yd=rd*math.cos(ang2)
                # i=0 時, 繪線起點由齒根圓上的點, 作為起點
                if(i==0):
                    last_x = midx+xd
                    last_y = midy-yd
                # 由右側齒根圓作為起點, 除第一點 (xd,yd) 齒根圓上的起點外, 其餘的 (xpt,ypt)則為漸開線上的分段點
                self.create_line((midx+xpt),(midy-ypt),(last_x),(last_y),fill=color)
                # 最後一點, 則為齒頂圓
                if(i==imax):
                    rfx=midx+xpt
                    rfy=midy-ypt
                last_x = midx+xpt
                last_y = midy-ypt
            # lfx 為齒頂圓上的左側 x 座標, lfy 則為 y 座標
            # 下列為齒頂圓上用來近似圓弧的直線
            self.create_line(lfx,lfy,rfx,rfy,fill=color)
canvas = doc['gear2']
ctx = canvas.getContext("2d")
x = (canvas.width)/2
y = (canvas.height)/2

n17 = 17
n11 = 11
n13 = 13

canvas_size = canvas.height*0.4
r17 = canvas_size*n17/(n17+n11+n13)
r11 = canvas_size*n11/(n17+n11+n13)
r13 = canvas_size*n13/(n17+n11+n13)

x17 = x - r17-r11
y17 = y

x11 = x 
y11 = y

x13 = x + r11+r13
y13 = y

# 齒數
#n = 17
# 壓力角
pa = 20
rot = 90
#gear1 = Spur(ctx).Gear(x, y, r, n, pa, "blue")
ctx.save()
ctx.translate(x17, y17)
ctx.rotate(90*deg)
ctx.translate(-x17, -y17)
gear17 = Spur(ctx).Gear(x17, y17, r17, n17, pa, "blue", rot)
ctx.restore()

ctx.save()
ctx.translate(x11, y11)
ctx.rotate(-90*deg-math.pi/n11)
ctx.translate(-x11, -y11)
gear11 = Spur(ctx).Gear(x11, y11, r11, n11, pa, "blue", rot)
ctx.restore()

ctx.save()
ctx.translate(x13, y13)
#ctx.rotate(-90*deg-math.pi/n13+(-90*deg-math.pi/n11)*n11/n13)
ctx.rotate(-90*deg-math.pi/n13+(180*deg+math.pi/n11)*n11/n13)
ctx.translate(-x13, -y13)
gear13 = Spur(ctx).Gear(x13, y13, r13, n13, pa, "blue", rot)
ctx.restore()
div = doc["onegear_div"]
div &lt;=  str(canvas.width) + "|" + str(canvas.height)
&lt;/script&gt;

&lt;p&gt;寫成 Fossil SCM 網頁互動式&lt;/p&gt;</summary><category term="2D與3D傳動正齒輪-W12"></category></entry><entry><title>W11-2D 正齒輪傳動</title><link href="./%E6%AD%A3%E9%BD%92%E8%BC%AA.html" rel="alternate"></link><published>2017-05-11T14:00:00+08:00</published><updated>2017-05-11T14:00:00+08:00</updated><author><name>40423104-YanSyuan</name></author><id>tag:,2017-05-11:./正齒輪.html</id><summary type="html">&lt;h4&gt;正齒輪傳動&lt;/h4&gt;
&lt;p&gt;從單一 2D 正齒輪繪圖到齒輪組嚙合&lt;/p&gt;


&lt;p&gt;利用漸開線原理, 以 Brython 繪製單一正齒輪廓:&lt;/p&gt;
&lt;!-- 導入 Brython 標準程式庫 --&gt;

&lt;script src="../data/Brython-3.3.1/brython.js"&gt;&lt;/script&gt;

&lt;script src="../data/Brython-3.3.1/brython_stdlib.js"&gt;&lt;/script&gt;

&lt;!-- 啟動 Brython --&gt;

&lt;script&gt;
window.onload=function(){
// 設定 data/py 為共用程式路徑
brython({debug:1, pythonpath:['./../data/py']});
}
&lt;/script&gt;

&lt;!-- 以下實際利用  Brython 繪圖--&gt;

&lt;canvas id="onegear" width="800" height="600"&gt;&lt;/canvas&gt;

&lt;div id="onegear_div" width="800" height="20"&gt;&lt;/div&gt;

&lt;script type="text/python3"&gt;
from browser import document as doc
import math
# deg 為角度轉為徑度的轉換因子
deg = math.pi/180.
# 定義 Spur 類別
class Spur(object):
    def __init__(self, ctx):
        self.ctx = ctx

    def create_line(self, x1, y1, x2, y2, width=3, fill="red"):
        self.ctx.beginPath()
        self.ctx.lineWidth = width
        self.ctx.moveTo(x1, y1)
        self.ctx.lineTo(x2, y2)
        self.ctx.strokeStyle = fill
        self.ctx.stroke()
    #
    # 定義一個繪正齒輪的繪圖函式
    # midx 為齒輪圓心 x 座標
    # midy 為齒輪圓心 y 座標
    # rp 為節圓半徑, n 為齒數
    # pa 為壓力角 (deg)
    # rot 為旋轉角 (deg)
    # 已經針對 n 大於等於 52 齒時的繪圖錯誤修正, 因為 base circle 與齒根圓大小必須進行判斷
    def Gear(self, midx, midy, rp, n=20, pa=20, color="black"):
        # 齒輪漸開線分成 15 線段繪製
        imax = 15
        # 在輸入的畫布上繪製直線, 由圓心到節圓 y 軸頂點畫一直線
        self.create_line(midx, midy, midx, midy-rp)
        # 畫出 rp 圓, 畫圓函式尚未定義
        #create_oval(midx-rp, midy-rp, midx+rp, midy+rp, width=2)
        # a 為模數 (代表公制中齒的大小), 模數為節圓直徑(稱為節徑)除以齒數
        # 模數也就是齒冠大小
        a=2*rp/n
        # d 為齒根大小, 為模數的 1.157 或 1.25倍, 這裡採 1.25 倍
        d=2.5*rp/n
        # ra 為齒輪的外圍半徑
        ra=rp+a
        # 畫出 ra 圓, 畫圓函式尚未定義
        #create_oval(midx-ra, midy-ra, midx+ra, midy+ra, width=1)
        # rb 則為齒輪的基圓半徑
        # 基圓為漸開線長齒之基準圓
        rb=rp*math.cos(pa*deg)
        # 畫出 rb 圓 (基圓), 畫圓函式尚未定義
        #create_oval(midx-rb, midy-rb, midx+rb, midy+rb, width=1)
        # rd 為齒根圓半徑
        rd=rp-d
        # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd
        # 畫出 rd 圓 (齒根圓), 畫圓函式尚未定義
        #create_oval(midx-rd, midy-rd, midx+rd, midy+rd, width=1)
        # dr 則為基圓到齒頂圓半徑分成 imax 段後的每段半徑增量大小
        # 將圓弧分成 imax 段來繪製漸開線
        # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd
        if rd&gt;rb:
            dr = (ra-rd)/imax
        else:
            dr=(ra-rb)/imax
        # tan(pa*deg)-pa*deg 為漸開線函數
        sigma=math.pi/(2*n)+math.tan(pa*deg)-pa*deg
        for j in range(n):
            ang=-2.*j*math.pi/n+sigma
            ang2=2.*j*math.pi/n+sigma
            lxd=midx+rd*math.sin(ang2-2.*math.pi/n)
            lyd=midy-rd*math.cos(ang2-2.*math.pi/n)
            for i in range(imax+1):
                # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd
                if rd&gt;rb:
                    r=rd+i*dr
                else:
                    r=rb+i*dr
                theta=math.sqrt((r*r)/(rb*rb)-1.)
                alpha=theta-math.atan(theta)
                xpt=r*math.sin(alpha-ang)
                ypt=r*math.cos(alpha-ang)
                xd=rd*math.sin(-ang)
                yd=rd*math.cos(-ang)
                # i=0 時, 繪線起點由齒根圓上的點, 作為起點
                if(i==0):
                    last_x = midx+xd
                    last_y = midy-yd
                # 由左側齒根圓作為起點, 除第一點 (xd,yd) 齒根圓上的起點外, 其餘的 (xpt,ypt)則為漸開線上的分段點
                self.create_line((midx+xpt),(midy-ypt),(last_x),(last_y),fill=color)
                # 最後一點, 則為齒頂圓
                if(i==imax):
                    lfx=midx+xpt
                    lfy=midy-ypt
                last_x = midx+xpt
                last_y = midy-ypt
            # the line from last end of dedendum point to the recent
            # end of dedendum point
            # lxd 為齒根圓上的左側 x 座標, lyd 則為 y 座標
            # 下列為齒根圓上用來近似圓弧的直線
            self.create_line((lxd),(lyd),(midx+xd),(midy-yd),fill=color)
            for i in range(imax+1):
                # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd
                if rd&gt;rb:
                    r=rd+i*dr
                else:
                    r=rb+i*dr
                theta=math.sqrt((r*r)/(rb*rb)-1.)
                alpha=theta-math.atan(theta)
                xpt=r*math.sin(ang2-alpha)
                ypt=r*math.cos(ang2-alpha)
                xd=rd*math.sin(ang2)
                yd=rd*math.cos(ang2)
                # i=0 時, 繪線起點由齒根圓上的點, 作為起點
                if(i==0):
                    last_x = midx+xd
                    last_y = midy-yd
                # 由右側齒根圓作為起點, 除第一點 (xd,yd) 齒根圓上的起點外, 其餘的 (xpt,ypt)則為漸開線上的分段點
                self.create_line((midx+xpt),(midy-ypt),(last_x),(last_y),fill=color)
                # 最後一點, 則為齒頂圓
                if(i==imax):
                    rfx=midx+xpt
                    rfy=midy-ypt
                last_x = midx+xpt
                last_y = midy-ypt
            # lfx 為齒頂圓上的左側 x 座標, lfy 則為 y 座標
            # 下列為齒頂圓上用來近似圓弧的直線
            self.create_line(lfx,lfy,rfx,rfy,fill=color)


# 準備在 id="onegear" 的 canvas 中繪圖
canvas = doc['onegear']
ctx = canvas.getContext("2d")
m = (0.8*canvas.width)/(n17+n11+n13)
# 壓力角
pa = 20
canvas_size = canvas.height*0.4
x = (canvas.width)/(2*(n17+n11+n13+n15))
y = (canvas.height)/2
y1=(canvas.height)/1.435
# 齒數
n17 = 17
n11 = 11
n13 = 13
n15 = 15
canvas_size = canvas.height*0.4
r17 = canvas_size*n17/(n17+n11+n13)
r11 = canvas_size*n11/(n17+n11+n13)
r13 = canvas_size*n13/(n17+n11+n13)
r15 = canvas_size*n15/(n17+n11+n13)
x17 = x - r17-r11
y17 = y
x11 = x
y11 = y
x13 = x + r11+r13
y13 = y
x15 = x + r11+r13
y15 = y1

#gear17
ctx.save()
ctx.translate(x17, y17)
ctx.rotate(math.pi/2)
ctx.translate(-x17, -y17)
gear17 = Spur(ctx).Gear(x17, y17, r17, n17, pa,"purple")
ctx.restore()

#gear11
ctx.save()
ctx.translate(x11, y11)
ctx.rotate(-math.pi/2-math.pi/n11)
ctx.translate(-x11, -y11)
gear11 = Spur(ctx).Gear(x11, y11, r11, n11, pa,"blue")
ctx.restore()

#gear13
ctx.save()
ctx.translate(x13, y13)
ctx.rotate(-90*deg-math.pi/n13+(-90*deg-math.pi/n11)*n11/n13,rot)
ctx.translate(-x13, -y13)
gear13 = Spur(ctx).Gear(x13, y13, r13, n13, pa,"red")
ctx.restore()

#gear15
ctx.save()
ctx.translate(x15, y15)
ctx.rotate(-90*deg-math.pi/n13-90*deg-math.pi/n11+(90*deg-math.pi/n15)*n11/n13/n15,rot)
ctx.translate(-x13, -y13)
gear15 = Spur(ctx).Gear(x15, y15, r15, n15, pa,"green")
ctx.restore()

&lt;/script&gt;

&lt;!-- 導入 Brython 標準程式庫 --&gt;

&lt;script src="/mde2a2/raw/Brython-3.3.1/brython.js?name=38acf95eafd1a3cd6b4429cb357536db72bbdd94"&gt;&lt;/script&gt;

&lt;script src="/mde2a2/raw/Brython-3.3.1/brython_stdlib.js?name=1e4caae7eb37d66564cd620d8bb62642248e31fe"&gt;&lt;/script&gt;

&lt;!-- 啟動 Brython --&gt;

&lt;script&gt;
window.onload=function(){
// 設定 data/py 為共用程式路徑
brython({debug:1, pythonpath:['./../data/py']});
}
&lt;/script&gt;

&lt;!-- 以下實際利用  Brython 繪圖--&gt;

&lt;canvas id="onegear1" width="800" height="600"&gt;&lt;/canvas&gt;

&lt;div id="onegear1_div" width="800" height="20"&gt;&lt;/div&gt;

&lt;script type="text/python3"&gt;
from browser import document as doc
import math
# deg 為角度轉為徑度的轉換因子
deg = math.pi/180.
# 定義 Spur 類別
class Spur(object):
    def __init__(self, ctx):
        self.ctx = ctx

    def create_line(self, x1, y1, x2, y2, width=3, fill="red"):
        self.ctx.beginPath()
        self.ctx.lineWidth = width
        self.ctx.moveTo(x1, y1)
        self.ctx.lineTo(x2, y2)
        self.ctx.strokeStyle = fill
        self.ctx.stroke()
    #
    # 定義一個繪正齒輪的繪圖函式
    # midx 為齒輪圓心 x 座標
    # midy 為齒輪圓心 y 座標
    # rp 為節圓半徑, n 為齒數
    # pa 為壓力角 (deg)
    # rot 為旋轉角 (deg)
    # 已經針對 n 大於等於 52 齒時的繪圖錯誤修正, 因為 base circle 與齒根圓大小必須進行判斷
    def Gear(self, midx, midy, rp, n=20, pa=20, color="black", rot):
        # 齒輪漸開線分成 15 線段繪製
        imax = 15
        # 在輸入的畫布上繪製直線, 由圓心到節圓 y 軸頂點畫一直線
        self.create_line(midx, midy, midx, midy-rp)
        # 畫出 rp 圓, 畫圓函式尚未定義
        #create_oval(midx-rp, midy-rp, midx+rp, midy+rp, width=2)
        # a 為模數 (代表公制中齒的大小), 模數為節圓直徑(稱為節徑)除以齒數
        # 模數也就是齒冠大小
        a=2*rp/n
        # d 為齒根大小, 為模數的 1.157 或 1.25倍, 這裡採 1.25 倍
        d=2.5*rp/n
        # ra 為齒輪的外圍半徑
        ra=rp+a
        # 畫出 ra 圓, 畫圓函式尚未定義
        #create_oval(midx-ra, midy-ra, midx+ra, midy+ra, width=1)
        # rb 則為齒輪的基圓半徑
        # 基圓為漸開線長齒之基準圓
        rb=rp*math.cos(pa*deg)
        # 畫出 rb 圓 (基圓), 畫圓函式尚未定義
        #create_oval(midx-rb, midy-rb, midx+rb, midy+rb, width=1)
        # rd 為齒根圓半徑
        rd=rp-d
        # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd
        # 畫出 rd 圓 (齒根圓), 畫圓函式尚未定義
        #create_oval(midx-rd, midy-rd, midx+rd, midy+rd, width=1)
        # dr 則為基圓到齒頂圓半徑分成 imax 段後的每段半徑增量大小
        # 將圓弧分成 imax 段來繪製漸開線
        # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd
        if rd&gt;rb:
            dr = (ra-rd)/imax
        else:
            dr=(ra-rb)/imax
        # tan(pa*deg)-pa*deg 為漸開線函數
        sigma=math.pi/(2*n)+math.tan(pa*deg)-pa*deg
        for j in range(n):
            ang=-2.*j*math.pi/n+sigma
            ang2=2.*j*math.pi/n+sigma
            lxd=midx+rd*math.sin(ang2-2.*math.pi/n)
            lyd=midy-rd*math.cos(ang2-2.*math.pi/n)
            for i in range(imax+1):
                # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd
                if rd&gt;rb:
                    r=rd+i*dr
                else:
                    r=rb+i*dr
                theta=math.sqrt((r*r)/(rb*rb)-1.)
                alpha=theta-math.atan(theta)
                xpt=r*math.sin(alpha-ang)
                ypt=r*math.cos(alpha-ang)
                xd=rd*math.sin(-ang)
                yd=rd*math.cos(-ang)
                # i=0 時, 繪線起點由齒根圓上的點, 作為起點
                if(i==0):
                    last_x = midx+xd
                    last_y = midy-yd
                # 由左側齒根圓作為起點, 除第一點 (xd,yd) 齒根圓上的起點外, 其餘的 (xpt,ypt)則為漸開線上的分段點
                self.create_line((midx+xpt),(midy-ypt),(last_x),(last_y),fill=color)
                # 最後一點, 則為齒頂圓
                if(i==imax):
                    lfx=midx+xpt
                    lfy=midy-ypt
                last_x = midx+xpt
                last_y = midy-ypt
            # the line from last end of dedendum point to the recent
            # end of dedendum point
            # lxd 為齒根圓上的左側 x 座標, lyd 則為 y 座標
            # 下列為齒根圓上用來近似圓弧的直線
            self.create_line((lxd),(lyd),(midx+xd),(midy-yd),fill=color)
            for i in range(imax+1):
                # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd
                if rd&gt;rb:
                    r=rd+i*dr
                else:
                    r=rb+i*dr
                theta=math.sqrt((r*r)/(rb*rb)-1.)
                alpha=theta-math.atan(theta)
                xpt=r*math.sin(ang2-alpha)
                ypt=r*math.cos(ang2-alpha)
                xd=rd*math.sin(ang2)
                yd=rd*math.cos(ang2)
                # i=0 時, 繪線起點由齒根圓上的點, 作為起點
                if(i==0):
                    last_x = midx+xd
                    last_y = midy-yd
                # 由右側齒根圓作為起點, 除第一點 (xd,yd) 齒根圓上的起點外, 其餘的 (xpt,ypt)則為漸開線上的分段點
                self.create_line((midx+xpt),(midy-ypt),(last_x),(last_y),fill=color)
                # 最後一點, 則為齒頂圓
                if(i==imax):
                    rfx=midx+xpt
                    rfy=midy-ypt
                last_x = midx+xpt
                last_y = midy-ypt
            # lfx 為齒頂圓上的左側 x 座標, lfy 則為 y 座標
            # 下列為齒頂圓上用來近似圓弧的直線
            self.create_line(lfx,lfy,rfx,rfy,fill=color)
canvas = doc['onegear1']
ctx = canvas.getContext("2d")
x = (canvas.width)/2
y = (canvas.height)/2

n17 = 17
n11 = 11
n13 = 13

canvas_size = canvas.height*0.4
r17 = canvas_size*n17/(n17+n11+n13)
r11 = canvas_size*n11/(n17+n11+n13)
r13 = canvas_size*n13/(n17+n11+n13)

x17 = x - r17-r11
y17 = y

x11 = x 
y11 = y

x13 = x + r11+r13
y13 = y

# 齒數
#n = 17
# 壓力角
pa = 20
rot = 90
#gear1 = Spur(ctx).Gear(x, y, r, n, pa, "blue")
ctx.save()
ctx.translate(x17, y17)
ctx.rotate(90*deg)
ctx.translate(-x17, -y17)
gear17 = Spur(ctx).Gear(x17, y17, r17, n17, pa, "blue", rot)
ctx.restore()

ctx.save()
ctx.translate(x11, y11)
ctx.rotate(-90*deg-math.pi/n11)
ctx.translate(-x11, -y11)
gear11 = Spur(ctx).Gear(x11, y11, r11, n11, pa, "blue", rot)
ctx.restore()

ctx.save()
ctx.translate(x13, y13)
#ctx.rotate(-90*deg-math.pi/n13+(-90*deg-math.pi/n11)*n11/n13)
ctx.rotate(-90*deg-math.pi/n13+(180*deg+math.pi/n11)*n11/n13)
ctx.translate(-x13, -y13)
gear13 = Spur(ctx).Gear(x13, y13, r13, n13, pa, "blue", rot)
ctx.restore()
div = doc["onegear_div"]
div &lt;=  str(canvas.width) + "|" + str(canvas.height)
&lt;/script&gt;

&lt;p&gt;(1) on shape:
  看完文章後了解on shape功能在產品設計中的應用外，可發現on shape在協同上的重視，如:追隨模式，方便讓合作夥伴與作者同步討論外，也能對產品特徵做及時修改，以及使用導入DXF檔的功能，能讓2D草圖匯入後，方便對照進行3D建模，建好的產品儲存後，可以去看時間軸了解產品變化。
(2) an Introduction to:
  在強調速度與創新的現代社會中，越快抓住市場趨勢改變的人就越有優勢，因此敏捷的產品設計在這時代是不可或缺的能力，由此可見設計使用的軟體越偏向快速、成本低、功能完備、方便討論的趨勢，若能縮短產品設計與發佈的時間，越能搶佔市場優勢，成為新潮產品，並獨佔專利權，團隊合作方面也不如以往，一人一台電腦CAD畫圖階段性接著畫，現在為節省時間，強調同步處理也就說到了，前面所提到的on shape，此軟體在現在要求敏捷產品設計的社會中，可發現在協同上的便利，一方面讓團隊能隨時注意組員畫圖進度若要組裝可以馬上應用外，一方面因為是網頁式開啟，比起以往需要帶著軟體到處跑，現在只需要有網路皆可開啟討論。
總心得:看完文章後了解了on shpae的便利性並對他的再產品設計中的地位有不同的認識，並也了解到了現代產品設計的趨勢與合作團隊模式的改變，或許現在的on shape還不能完全取代許多繪圖軟體，但相信在未來一步步改善後，非常有機會成為未來產品設計的主流。&lt;/p&gt;</summary><category term="正齒輪-W11"></category></entry><entry><title>2D 正齒輪傳動</title><link href="./%E6%AD%A3%E9%BD%92%E8%BC%AAW.html" rel="alternate"></link><published>2017-05-11T14:00:00+08:00</published><updated>2017-05-11T14:00:00+08:00</updated><author><name>40423104-YanSyuan</name></author><id>tag:,2017-05-11:./正齒輪W.html</id><summary type="html">&lt;h4&gt;正齒輪傳動&lt;/h4&gt;
&lt;p&gt;從單一 2D 正齒輪繪圖到齒輪組嚙合&lt;/p&gt;


&lt;p&gt;利用漸開線原理, 以 Brython 繪製單一正齒輪廓:&lt;/p&gt;
&lt;!-- 導入 Brython 標準程式庫 --&gt;

&lt;script src="../data/Brython-3.3.1/brython.js"&gt;&lt;/script&gt;

&lt;script src="../data/Brython-3.3.1/brython_stdlib.js"&gt;&lt;/script&gt;

&lt;!-- 啟動 Brython --&gt;

&lt;script&gt;
window.onload=function(){
// 設定 data/py 為共用程式路徑
brython({debug:1, pythonpath:['./../data/py']});
}
&lt;/script&gt;

&lt;!-- 以下實際利用  Brython 繪圖--&gt;

&lt;canvas id="onegear" width="800" height="600"&gt;&lt;/canvas&gt;

&lt;div id="onegear_div" width="800" height="20"&gt;&lt;/div&gt;

&lt;script type="text/python3"&gt;
from browser import document as doc
import math
# deg 為角度轉為徑度的轉換因子
deg = math.pi/180.
# 定義 Spur 類別
class Spur(object):
    def __init__(self, ctx):
        self.ctx = ctx

    def create_line(self, x1, y1, x2, y2, width=3, fill="red"):
        self.ctx.beginPath()
        self.ctx.lineWidth = width
        self.ctx.moveTo(x1, y1)
        self.ctx.lineTo(x2, y2)
        self.ctx.strokeStyle = fill
        self.ctx.stroke()
    #
    # 定義一個繪正齒輪的繪圖函式
    # midx 為齒輪圓心 x 座標
    # midy 為齒輪圓心 y 座標
    # rp 為節圓半徑, n 為齒數
    # pa 為壓力角 (deg)
    # rot 為旋轉角 (deg)
    # 已經針對 n 大於等於 52 齒時的繪圖錯誤修正, 因為 base circle 與齒根圓大小必須進行判斷
    def Gear(self, midx, midy, rp, n=20, pa=20, color="black"):
        # 齒輪漸開線分成 15 線段繪製
        imax = 15
        # 在輸入的畫布上繪製直線, 由圓心到節圓 y 軸頂點畫一直線
        self.create_line(midx, midy, midx, midy-rp)
        # 畫出 rp 圓, 畫圓函式尚未定義
        #create_oval(midx-rp, midy-rp, midx+rp, midy+rp, width=2)
        # a 為模數 (代表公制中齒的大小), 模數為節圓直徑(稱為節徑)除以齒數
        # 模數也就是齒冠大小
        a=2*rp/n
        # d 為齒根大小, 為模數的 1.157 或 1.25倍, 這裡採 1.25 倍
        d=2.5*rp/n
        # ra 為齒輪的外圍半徑
        ra=rp+a
        # 畫出 ra 圓, 畫圓函式尚未定義
        #create_oval(midx-ra, midy-ra, midx+ra, midy+ra, width=1)
        # rb 則為齒輪的基圓半徑
        # 基圓為漸開線長齒之基準圓
        rb=rp*math.cos(pa*deg)
        # 畫出 rb 圓 (基圓), 畫圓函式尚未定義
        #create_oval(midx-rb, midy-rb, midx+rb, midy+rb, width=1)
        # rd 為齒根圓半徑
        rd=rp-d
        # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd
        # 畫出 rd 圓 (齒根圓), 畫圓函式尚未定義
        #create_oval(midx-rd, midy-rd, midx+rd, midy+rd, width=1)
        # dr 則為基圓到齒頂圓半徑分成 imax 段後的每段半徑增量大小
        # 將圓弧分成 imax 段來繪製漸開線
        # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd
        if rd&gt;rb:
            dr = (ra-rd)/imax
        else:
            dr=(ra-rb)/imax
        # tan(pa*deg)-pa*deg 為漸開線函數
        sigma=math.pi/(2*n)+math.tan(pa*deg)-pa*deg
        for j in range(n):
            ang=-2.*j*math.pi/n+sigma
            ang2=2.*j*math.pi/n+sigma
            lxd=midx+rd*math.sin(ang2-2.*math.pi/n)
            lyd=midy-rd*math.cos(ang2-2.*math.pi/n)
            for i in range(imax+1):
                # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd
                if rd&gt;rb:
                    r=rd+i*dr
                else:
                    r=rb+i*dr
                theta=math.sqrt((r*r)/(rb*rb)-1.)
                alpha=theta-math.atan(theta)
                xpt=r*math.sin(alpha-ang)
                ypt=r*math.cos(alpha-ang)
                xd=rd*math.sin(-ang)
                yd=rd*math.cos(-ang)
                # i=0 時, 繪線起點由齒根圓上的點, 作為起點
                if(i==0):
                    last_x = midx+xd
                    last_y = midy-yd
                # 由左側齒根圓作為起點, 除第一點 (xd,yd) 齒根圓上的起點外, 其餘的 (xpt,ypt)則為漸開線上的分段點
                self.create_line((midx+xpt),(midy-ypt),(last_x),(last_y),fill=color)
                # 最後一點, 則為齒頂圓
                if(i==imax):
                    lfx=midx+xpt
                    lfy=midy-ypt
                last_x = midx+xpt
                last_y = midy-ypt
            # the line from last end of dedendum point to the recent
            # end of dedendum point
            # lxd 為齒根圓上的左側 x 座標, lyd 則為 y 座標
            # 下列為齒根圓上用來近似圓弧的直線
            self.create_line((lxd),(lyd),(midx+xd),(midy-yd),fill=color)
            for i in range(imax+1):
                # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd
                if rd&gt;rb:
                    r=rd+i*dr
                else:
                    r=rb+i*dr
                theta=math.sqrt((r*r)/(rb*rb)-1.)
                alpha=theta-math.atan(theta)
                xpt=r*math.sin(ang2-alpha)
                ypt=r*math.cos(ang2-alpha)
                xd=rd*math.sin(ang2)
                yd=rd*math.cos(ang2)
                # i=0 時, 繪線起點由齒根圓上的點, 作為起點
                if(i==0):
                    last_x = midx+xd
                    last_y = midy-yd
                # 由右側齒根圓作為起點, 除第一點 (xd,yd) 齒根圓上的起點外, 其餘的 (xpt,ypt)則為漸開線上的分段點
                self.create_line((midx+xpt),(midy-ypt),(last_x),(last_y),fill=color)
                # 最後一點, 則為齒頂圓
                if(i==imax):
                    rfx=midx+xpt
                    rfy=midy-ypt
                last_x = midx+xpt
                last_y = midy-ypt
            # lfx 為齒頂圓上的左側 x 座標, lfy 則為 y 座標
            # 下列為齒頂圓上用來近似圓弧的直線
            self.create_line(lfx,lfy,rfx,rfy,fill=color)


# 準備在 id="onegear" 的 canvas 中繪圖
canvas = doc['onegear']
ctx = canvas.getContext("2d")
# x = (canvas.width)/2
# y = (canvas.height)/2
# r = 0.8*(canvas.height/2)
x = (canvas.width)/2
y = (canvas.height)/2
y1=(canvas.height)/1.435
# 齒數
n17 = 17
n11 = 11
n13 = 13
n15 = 15
canvas_size = canvas.height*0.4
r17 = canvas_size*n17/(n17+n11+n13+n15)
r11 = canvas_size*n11/(n17+n11+n13+n15)
r13 = canvas_size*n13/(n17+n11+n13+n15)
r15 = canvas_size*n14/(n17+n11+n13+n15)
x17 = x-5 - r17
y17 = y
x11 = x-5 + r11
y11 = y
x13 = x-5+ 2*r11 + r13
y13 = y
x15 = x-5+ 2*r11 + r13
y15 = y1
m = (0.8*canvas.width)/(n17+n11+n13)
# 壓力角
pa = 20

#gear17
ctx.save()
ctx.translate(x17, y17)
ctx.rotate(math.pi/2)
ctx.translate(-x17, -y17)
gear17 = Spur(ctx).Gear(x17, y17, r17, n17, pa,"purple",rot)
ctx.restore()

#gear11
ctx.save()
ctx.translate(x11, y11)
ctx.rotate(-math.pi/2-math.pi/n11)
ctx.translate(-x11, -y11)
gear11 = Spur(ctx).Gear(x11, y11, r11, n11, pa,"blue",rot)
ctx.restore()

#gear13
ctx.save()
ctx.translate(x13, y13)
ctx.rotate(-90*deg-math.pi/n13+(-90*deg-math.pi/n11)*n11/n13,rot)
ctx.translate(-x13, -y13)
gear13 = Spur(ctx).Gear(x13, y13, r13, n13, pa,"red",rot)
ctx.restore()

#gear15
ctx.save()
ctx.translate(x15, y15)
ctx.rotate(-90*deg-math.pi/n13-90*deg-math.pi/n11+(90*deg-math.pi/n15)*n11/n13/n15,rot)
ctx.translate(-x13, -y13)
gear15 = Spur(ctx).Gear(x15, y15, r15, n15, pa,"green",rot)
ctx.restore()

&lt;/script&gt;</summary><category term="正齒輪W"></category></entry><entry><title>W10-加減乘除查驗</title><link href="./%E5%8A%A0%E6%B8%9B%E4%B9%98%E9%99%A4%E6%9F%A5%E9%A9%97.html" rel="alternate"></link><published>2017-04-27T17:00:00+08:00</published><updated>2017-04-27T17:00:00+08:00</updated><author><name>40423104-YanSyuan</name></author><id>tag:,2017-04-27:./加減乘除查驗.html</id><summary type="html">&lt;h4&gt;利用程式做加減乘除的運算&lt;/h4&gt;


&lt;h3&gt;1.先建立一個較m1的資料夾(配合程式)&lt;/h3&gt;
&lt;h3&gt;2.將以下兩個程式碼放在m1資料夾&lt;/h3&gt;
&lt;h3&gt;3.按鈕程式碼&lt;/h3&gt;
&lt;p&gt;&lt;pre class="brush: python"&gt;
&lt;!-- 導入 Brython 標準程式庫 --&gt;&lt;/p&gt;
&lt;script src="../data/Brython-3.3.1/brython.js"&gt;&lt;/script&gt;

&lt;script src="../data/Brython-3.3.1/brython_stdlib.js"&gt;&lt;/script&gt;

&lt;!-- 啟動 Brython --&gt;

&lt;script&gt;
window.onload=function(){
// 設定 data/py 為共用程式路徑
brython({debug:1, pythonpath:['./../data/py']});
}
&lt;/script&gt;

&lt;!-- 以下實際利用  Brython 畫四連桿 trace point 路徑--&gt;

&lt;!--&lt;canvas id="w10" width="800" height="600"&gt;&lt;/canvas&gt;--&gt;

&lt;div id="container" width="600" height="400"&gt;&lt;/div&gt;

&lt;script type="text/python3"&gt;
from browser import document as doc
from browser import html
import math
container = doc['container']
degree = math.pi/180
def button1(event):
    a = input("give me a")
    container &lt;= str(math.cos(60*degree)+float(a))
doc["button1"].bind("click", button1)
&lt;/script&gt;

&lt;p&gt;&lt;button id="button1"&gt;按下取 a 值&lt;/button&gt;
&lt;/pre&gt;&lt;/p&gt;
&lt;h2&gt;加運算&lt;/h2&gt;
&lt;h4&gt;程式碼&lt;/h4&gt;
&lt;p&gt;&lt;p&gt;檔名append.py&lt;/p&gt;
&lt;pre&gt;
def addend (a,b):
      return a+b
&lt;/pre&gt;
&lt;p&gt;檔名app.py&lt;/p&gt;
&lt;pre&gt;
import sys
sys.path.append("./m3")
import addend&lt;/p&gt;
&lt;p&gt;sum = addend.addend (19,88)&lt;/p&gt;
&lt;p&gt;print(sum)
&lt;/pre&gt;&lt;/p&gt;
&lt;p&gt;驗證影片&lt;/p&gt;
&lt;iframe src="https://player.vimeo.com/video/215938725" width="640" height="344" frameborder="0" webkitallowfullscreen mozallowfullscreen allowfullscreen&gt;&lt;/iframe&gt;

&lt;p&gt;按鈕測試&lt;/p&gt;
&lt;!-- 導入 Brython 標準程式庫 --&gt;

&lt;script src="../data/Brython-3.3.1/brython.js"&gt;&lt;/script&gt;

&lt;script src="../data/Brython-3.3.1/brython_stdlib.js"&gt;&lt;/script&gt;

&lt;!-- 啟動 Brython --&gt;

&lt;script&gt;
window.onload=function(){
// 設定 data/py 為共用程式路徑
brython({debug:1, pythonpath:['./../data/py']});
}
&lt;/script&gt;

&lt;!-- 以下實際利用  Brython 畫四連桿 trace point 路徑--&gt;

&lt;!--&lt;canvas id="w10" width="800" height="600"&gt;&lt;/canvas&gt;--&gt;

&lt;div id="container" width="600" height="400"&gt;&lt;/div&gt;

&lt;script type="text/python3"&gt;
from browser import document as doc
from browser import html
import math
container = doc['container']
degree = math.pi/180
def button1(event):
    a = input("give me a")
    b = input("give me b")
    container &lt;= str(float(a)+float(b))
doc["button1"].bind("click", button1)

&lt;/script&gt;

&lt;p&gt;&lt;button id="button1"&gt;按下取 a b 值&lt;/button&gt;&lt;/p&gt;
&lt;h2&gt;減運算&lt;/h2&gt;
&lt;h4&gt;程式碼&lt;/h4&gt;
&lt;p&gt;&lt;p&gt;檔名minus.py&lt;/p&gt;
&lt;pre&gt;
def minus (a,b):
      return a-b
&lt;/pre&gt;
&lt;p&gt;檔名app.py&lt;/p&gt;
&lt;pre&gt;
import sys
sys.path.append("./m4")
import minus&lt;/p&gt;
&lt;p&gt;sum = minus.minus (698,2278)&lt;/p&gt;
&lt;p&gt;print(sum)
&lt;/pre&gt;&lt;/p&gt;
&lt;p&gt;驗證影片&lt;/p&gt;
&lt;iframe src="https://player.vimeo.com/video/215939173" width="640" height="344" frameborder="0" webkitallowfullscreen mozallowfullscreen allowfullscreen&gt;&lt;/iframe&gt;

&lt;p&gt;按鈕測試&lt;/p&gt;
&lt;!-- 導入 Brython 標準程式庫 --&gt;

&lt;script src="../data/Brython-3.3.1/brython.js"&gt;&lt;/script&gt;

&lt;script src="../data/Brython-3.3.1/brython_stdlib.js"&gt;&lt;/script&gt;

&lt;!-- 啟動 Brython --&gt;

&lt;script&gt;
window.onload=function(){
// 設定 data/py 為共用程式路徑
brython({debug:1, pythonpath:['./../data/py']});
}
&lt;/script&gt;

&lt;!-- 以下實際利用  Brython 畫四連桿 trace point 路徑--&gt;

&lt;!--&lt;canvas id="w10" width="800" height="600"&gt;&lt;/canvas&gt;--&gt;

&lt;div id="container1" width="600" height="400"&gt;&lt;/div&gt;

&lt;script type="text/python3"&gt;
from browser import document as doc
from browser import html
import math
container = doc['container1']
degree = math.pi/180
def button2(event):
    a = input("give me a")
    b = input("give me b")
    container &lt;= str(float(a)-float(b))
doc["button2"].bind("click", button2)

&lt;/script&gt;

&lt;p&gt;&lt;button id="button2"&gt;按下取 a b 值&lt;/button&gt;&lt;/p&gt;
&lt;h2&gt;乘運算&lt;/h2&gt;
&lt;h4&gt;程式碼&lt;/h4&gt;
&lt;p&gt;&lt;p&gt;檔名tines.py&lt;/p&gt;
&lt;pre&gt;
def tines (a,b):
      return a*b
&lt;/pre&gt;
&lt;p&gt;檔名app.py&lt;/p&gt;
&lt;pre&gt;
import sys
sys.path.append("./m1")
import tines&lt;/p&gt;
&lt;p&gt;sum = tines.tines (4,2)&lt;/p&gt;
&lt;p&gt;print(sum)
&lt;/pre&gt;&lt;/p&gt;
&lt;p&gt;驗證影片&lt;/p&gt;
&lt;iframe src="https://player.vimeo.com/video/215937328" width="640" height="344" frameborder="0" webkitallowfullscreen mozallowfullscreen allowfullscreen&gt;&lt;/iframe&gt;

&lt;p&gt;按鈕測試&lt;/p&gt;
&lt;!-- 導入 Brython 標準程式庫 --&gt;

&lt;script src="../data/Brython-3.3.1/brython.js"&gt;&lt;/script&gt;

&lt;script src="../data/Brython-3.3.1/brython_stdlib.js"&gt;&lt;/script&gt;

&lt;!-- 啟動 Brython --&gt;

&lt;script&gt;
window.onload=function(){
// 設定 data/py 為共用程式路徑
brython({debug:1, pythonpath:['./../data/py']});
}
&lt;/script&gt;

&lt;!-- 以下實際利用  Brython 畫四連桿 trace point 路徑--&gt;

&lt;!--&lt;canvas id="w10" width="800" height="600"&gt;&lt;/canvas&gt;--&gt;

&lt;div id="container3" width="600" height="400"&gt;&lt;/div&gt;

&lt;script type="text/python3"&gt;
from browser import document as doc
from browser import html
import math
container = doc['container3']
degree = math.pi/180
def button3(event):
    a = input("give me a")
    b = input("give me b")
    container &lt;= str(float(a)*float(b))
doc["button3"].bind("click", button3)

&lt;/script&gt;

&lt;p&gt;&lt;button id="button3"&gt;按下取 a b 值&lt;/button&gt;&lt;/p&gt;
&lt;h3&gt;除運算&lt;/h3&gt;
&lt;h4&gt;程式碼&lt;/h4&gt;
&lt;p&gt;&lt;p&gt;檔名divided.py&lt;/p&gt;
&lt;pre&gt;
def divided (a,b):
      return a/b
&lt;/pre&gt;
&lt;p&gt;檔名app.py&lt;/p&gt;
&lt;pre&gt;
import sys
sys.path.append("./m2")
import divided&lt;/p&gt;
&lt;p&gt;sum = divided.divided (3,2)&lt;/p&gt;
&lt;p&gt;print(sum)
&lt;/pre&gt;&lt;/p&gt;
&lt;p&gt;驗證影片&lt;/p&gt;
&lt;iframe src="https://player.vimeo.com/video/215938127" width="640" height="344" frameborder="0" webkitallowfullscreen mozallowfullscreen allowfullscreen&gt;&lt;/iframe&gt;

&lt;p&gt;按鈕測試&lt;/p&gt;
&lt;!-- 導入 Brython 標準程式庫 --&gt;

&lt;script src="../data/Brython-3.3.1/brython.js"&gt;&lt;/script&gt;

&lt;script src="../data/Brython-3.3.1/brython_stdlib.js"&gt;&lt;/script&gt;

&lt;!-- 啟動 Brython --&gt;

&lt;script&gt;
window.onload=function(){
// 設定 data/py 為共用程式路徑
brython({debug:1, pythonpath:['./../data/py']});
}
&lt;/script&gt;

&lt;!-- 以下實際利用  Brython 畫四連桿 trace point 路徑--&gt;

&lt;!--&lt;canvas id="w10" width="800" height="600"&gt;&lt;/canvas&gt;--&gt;

&lt;div id="container4" width="600" height="400"&gt;&lt;/div&gt;

&lt;script type="text/python3"&gt;
from browser import document as doc
from browser import html
import math
container = doc['container4']
degree = math.pi/180
def button4(event):
    a = input("give me a")
    b = input("give me b")
    container &lt;= str(float(a)/float(b))
doc["button4"].bind("click", button4)

&lt;/script&gt;

&lt;p&gt;&lt;button id="button4"&gt;按下取 a b 值&lt;/button&gt;&lt;/p&gt;</summary><category term="加減乘除查驗-W10"></category></entry><entry><title>期中協同</title><link href="./%E6%9C%9F%E4%B8%AD.html" rel="alternate"></link><published>2017-04-20T13:20:00+08:00</published><updated>2017-04-20T13:20:00+08:00</updated><author><name>40423104-YanSyuan</name></author><id>tag:,2017-04-20:./期中.html</id><summary type="html">&lt;h4&gt;Fossil Server 實習查驗&lt;/h4&gt;
&lt;h4&gt;四連桿機構協同 Trace Point 查驗&lt;/h4&gt;
&lt;h4&gt;Fourbar Walker OnShape 零件協同繪圖與組立查驗&lt;/h4&gt;


&lt;h2&gt;[1] Fossil Server 實習查驗&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://mde2a2.kmol.info/midterm/ag2/wcontent"&gt;https://mde2a2.kmol.info/midterm/ag2/wcontent&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;[2] 四連桿機構協同 Trace Point 查驗&lt;/h2&gt;
&lt;h4&gt;利用solvespace繪製機構尺寸並模擬路徑在導入excel查驗&lt;/h4&gt;
&lt;h3&gt;第一種尺寸修改&lt;/h3&gt;
&lt;h3&gt;繪製機構尺寸並模擬(L=40)&lt;/h3&gt;
&lt;p&gt;&lt;iframe src="https://player.vimeo.com/video/214898008" width="640" height="344" frameborder="0" webkitallowfullscreen mozallowfullscreen allowfullscreen&gt;&lt;/iframe&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://imgur.com/fQfeSWr"&gt;&lt;img src="http://i.imgur.com/fQfeSWr.png" title="source: imgur.com" /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;excel查驗&lt;/h3&gt;
&lt;p&gt;&lt;a href="http://imgur.com/OvWMa1p"&gt;&lt;img src="http://i.imgur.com/OvWMa1p.png" title="source: imgur.com" /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;第二種尺寸修改&lt;/h3&gt;
&lt;h3&gt;繪製機構尺寸並模擬(L=40)&lt;/h3&gt;
&lt;p&gt;&lt;iframe src="https://player.vimeo.com/video/214902196" width="640" height="344" frameborder="0" webkitallowfullscreen mozallowfullscreen allowfullscreen&gt;&lt;/iframe&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://imgur.com/CMi7Zyz"&gt;&lt;img src="http://i.imgur.com/CMi7Zyz.png" title="source: imgur.com" /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;excel查驗&lt;/h3&gt;
&lt;p&gt;&lt;a href="http://imgur.com/jFAisIq"&gt;&lt;img src="http://i.imgur.com/jFAisIq.png" title="source: imgur.com" /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;[3] Fourbar Walker OnShape 零件協同繪圖與組立查驗&lt;/h2&gt;
&lt;h4&gt;利用solvespace繪製機構尺寸&lt;/h4&gt;
&lt;p&gt;&lt;a href="http://imgur.com/qeDUQdF"&gt;&lt;img src="http://i.imgur.com/qeDUQdF.png" title="source: imgur.com" /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;影片&lt;/h3&gt;
&lt;p&gt;&lt;iframe src="https://player.vimeo.com/video/214880324" width="640" height="360" frameborder="0" webkitallowfullscreen mozallowfullscreen allowfullscreen&gt;&lt;/iframe&gt;&lt;/p&gt;
&lt;h4&gt;利用onshape繪製零件圖與組裝模擬&lt;/h4&gt;
&lt;h3&gt;零件一主體&lt;/h3&gt;
&lt;p&gt;&lt;iframe src="https://player.vimeo.com/video/214882891" width="640" height="360" frameborder="0" webkitallowfullscreen mozallowfullscreen allowfullscreen&gt;&lt;/iframe&gt;&lt;/p&gt;
&lt;h3&gt;所有桿件繪製&lt;/h3&gt;
&lt;p&gt;&lt;iframe src="https://player.vimeo.com/video/214882073" width="640" height="360" frameborder="0" webkitallowfullscreen mozallowfullscreen allowfullscreen&gt;&lt;/iframe&gt;&lt;/p&gt;
&lt;h3&gt;組裝&lt;/h3&gt;
&lt;p&gt;&lt;iframe src="https://player.vimeo.com/video/214944513" width="640" height="343" frameborder="0" webkitallowfullscreen mozallowfullscreen allowfullscreen&gt;&lt;/iframe&gt;&lt;/p&gt;
&lt;h3&gt;模擬&lt;/h3&gt;
&lt;p&gt;&lt;iframe src="https://player.vimeo.com/video/214729992" width="640" height="343" frameborder="0" webkitallowfullscreen mozallowfullscreen allowfullscreen&gt;&lt;/iframe&gt;&lt;/p&gt;</summary><category term="期中協同"></category></entry><entry><title>V-rep模擬操作(祥細)</title><link href="./V-rep%E6%93%8D%E4%BD%9C.html" rel="alternate"></link><published>2017-04-18T17:00:00+08:00</published><updated>2017-04-18T17:00:00+08:00</updated><author><name>40423104-YanSyuan</name></author><id>tag:,2017-04-18:./V-rep操作.html</id><summary type="html">&lt;h4&gt;轉入V-REP並模擬及轉入作法&lt;/h4&gt;


&lt;h3&gt;1.導入 STL 3D圖檔&lt;/h3&gt;
&lt;p&gt;&lt;a href="http://imgur.com/byoORo7"&gt;&lt;img src="http://i.imgur.com/byoORo7.png" title="source: imgur.com" /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;2.可先調整圖的位置&lt;/h3&gt;
&lt;p&gt;&lt;a href="http://imgur.com/VW5pBOR"&gt;&lt;img src="http://i.imgur.com/VW5pBOR.png" title="source: imgur.com" /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;3.分解組合圖(每件變成單一個體)&lt;/h3&gt;
&lt;p&gt;&lt;a href="http://imgur.com/12OHaFy"&gt;&lt;img src="http://i.imgur.com/12OHaFy.png" title="source: imgur.com" /&gt;&lt;/a&gt;
&lt;a href="http://imgur.com/Edd28T2"&gt;&lt;img src="http://i.imgur.com/Edd28T2.png" title="source: imgur.com" /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;4.導入圓柱&lt;/h3&gt;
&lt;p&gt;&lt;a href="http://imgur.com/KJMFJQ7"&gt;&lt;img src="http://i.imgur.com/KJMFJQ7.png" title="source: imgur.com" /&gt;&lt;/a&gt;
&lt;a href="http://imgur.com/cXaH1ZH"&gt;&lt;img src="http://i.imgur.com/cXaH1ZH.png" title="source: imgur.com" /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;5.將圓柱與軸對齊中心&lt;/h3&gt;
&lt;p&gt;&lt;a href="http://imgur.com/WGANwBU"&gt;&lt;img src="http://i.imgur.com/WGANwBU.png" title="source: imgur.com" /&gt;&lt;/a&gt;
&lt;a href="http://imgur.com/VmMz0Vo"&gt;&lt;img src="http://i.imgur.com/VmMz0Vo.png" title="source: imgur.com" /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;6.調整軸轉動的速度&lt;/h3&gt;
&lt;p&gt;&lt;a href="http://imgur.com/HGMpJmb"&gt;&lt;img src="http://i.imgur.com/HGMpJmb.png" title="source: imgur.com" /&gt;&lt;/a&gt;
&lt;a href="http://imgur.com/LbXtSgu"&gt;&lt;img src="http://i.imgur.com/LbXtSgu.png" title="source: imgur.com" /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;7.調整桿件設定&lt;/h3&gt;
&lt;p&gt;&lt;a href="http://imgur.com/VmMz0Vo"&gt;&lt;img src="http://i.imgur.com/VmMz0Vo.png" title="source: imgur.com" /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;8.模擬&lt;/h3&gt;
&lt;p&gt;&lt;a href="http://imgur.com/SAORFYj"&gt;&lt;img src="http://i.imgur.com/SAORFYj.png" title="source: imgur.com" /&gt;&lt;/a&gt;&lt;/p&gt;</summary><category term="V-rep模擬"></category></entry><entry><title>W6-onshape與V-rep四連桿、八連桿</title><link href="./onshape%E8%88%87V-rep.html" rel="alternate"></link><published>2017-03-30T12:00:00+08:00</published><updated>2017-03-30T12:00:00+08:00</updated><author><name>40423104-YanSyuan</name></author><id>tag:,2017-03-30:./onshape與V-rep.html</id><summary type="html">&lt;h4&gt;利用onshape繪製與組裝四連桿、八連桿&lt;/h4&gt;
&lt;h4&gt;轉入V-REP並模擬&lt;/h4&gt;


&lt;h3&gt;四連桿影片&lt;/h3&gt;
&lt;h4&gt;桿件20&lt;/h4&gt;
&lt;p&gt;&lt;iframe src="https://player.vimeo.com/video/210709563" width="640" height="360" frameborder="0" webkitallowfullscreen mozallowfullscreen allowfullscreen&gt;&lt;/iframe&gt;&lt;/p&gt;
&lt;h4&gt;桿件30&lt;/h4&gt;
&lt;p&gt;&lt;iframe src="https://player.vimeo.com/video/210709572" width="640" height="360" frameborder="0" webkitallowfullscreen mozallowfullscreen allowfullscreen&gt;&lt;/iframe&gt;&lt;/p&gt;
&lt;h4&gt;桿件50&lt;/h4&gt;
&lt;p&gt;&lt;iframe src="https://player.vimeo.com/video/210709757" width="640" height="360" frameborder="0" webkitallowfullscreen mozallowfullscreen allowfullscreen&gt;&lt;/iframe&gt;&lt;/p&gt;
&lt;h4&gt;桿件60&lt;/h4&gt;
&lt;p&gt;&lt;iframe src="https://player.vimeo.com/video/210709915" width="640" height="360" frameborder="0" webkitallowfullscreen mozallowfullscreen allowfullscreen&gt;&lt;/iframe&gt;&lt;/p&gt;
&lt;h4&gt;桿件組合&lt;/h4&gt;
&lt;p&gt;&lt;iframe src="https://player.vimeo.com/video/211774477" width="640" height="360" frameborder="0" webkitallowfullscreen mozallowfullscreen allowfullscreen&gt;&lt;/iframe&gt;&lt;/p&gt;
&lt;h4&gt;轉入V-rep模擬&lt;/h4&gt;
&lt;p&gt;&lt;iframe src="https://player.vimeo.com/video/214558908" width="640" height="343" frameborder="0" webkitallowfullscreen mozallowfullscreen allowfullscreen&gt;&lt;/iframe&gt;
&lt;p&gt;&lt;a href="https://vimeo.com/214558908"&gt;虎尾科技大學 機械設計工程系-40423104-W6-四連桿模擬V-rep&lt;/a&gt; from &lt;a href="https://vimeo.com/user44900188"&gt;40423104-Yan syuan&lt;/a&gt; on &lt;a href="https://vimeo.com"&gt;Vimeo&lt;/a&gt;.&lt;/p&gt;&lt;/p&gt;
&lt;h3&gt;八連桿影片&lt;/h3&gt;
&lt;h4&gt;桿件繪製(一)&lt;/h4&gt;
&lt;p&gt;中心距分別為:15mm、50mm、64mm&lt;/p&gt;
&lt;p&gt;L型桿件:6mmx40mm&lt;/p&gt;
&lt;iframe src="https://player.vimeo.com/video/214740141" width="640" height="360" frameborder="0" webkitallowfullscreen mozallowfullscreen allowfullscreen&gt;&lt;/iframe&gt;

&lt;h4&gt;桿件繪製(二)&lt;/h4&gt;
&lt;p&gt;中心距分別為:40mm、50mm&lt;/p&gt;
&lt;p&gt;三角形尺寸:40mm、40mm、56mm&lt;/p&gt;
&lt;p&gt;角度100度L型桿件:18mm、25mm、R45mm&lt;/p&gt;
&lt;iframe src="https://player.vimeo.com/video/214741635" width="640" height="360" frameborder="0" webkitallowfullscreen mozallowfullscreen allowfullscreen&gt;&lt;/iframe&gt;

&lt;h4&gt;桿件組合&lt;/h4&gt;
&lt;iframe src="https://player.vimeo.com/video/214777688" width="640" height="360" frameborder="0" webkitallowfullscreen mozallowfullscreen allowfullscreen&gt;&lt;/iframe&gt;

&lt;h4&gt;轉入V-rep模擬&lt;/h4&gt;
&lt;iframe src="https://player.vimeo.com/video/214958790" width="640" height="346" frameborder="0" webkitallowfullscreen mozallowfullscreen allowfullscreen&gt;&lt;/iframe&gt;

&lt;h3&gt;心得&lt;/h3&gt;
&lt;p&gt;&lt;p&gt;1.操作八連桿模擬要一個桿件慢慢來測試模擬，才不會一直模擬失敗&lt;/p&gt;
&lt;p&gt;2.透過設計八連桿尺寸，更熟知設計時要注意到的桿件長度與需不需要加入特殊固定&lt;/p&gt;
&lt;p&gt;3.在onshape中組裝零件須注意要使用轉動配合，才能方便在V-rep中模擬 &lt;/p&gt;&lt;/p&gt;</summary><category term="onshape與V-rep-W6"></category></entry><entry><title>W5-V-rep模擬</title><link href="./V-rep.html" rel="alternate"></link><published>2017-03-23T15:00:00+08:00</published><updated>2017-03-23T15:00:00+08:00</updated><author><name>40423104-YanSyuan</name></author><id>tag:,2017-03-23:./V-rep.html</id><summary type="html">&lt;h4&gt;利用V-rep 將單連桿機構導入，在進行模擬&lt;/h4&gt;
&lt;h4&gt;簡單介紹 Git Hub 改版問題&lt;/h4&gt;


&lt;h3&gt;單連桿影片&lt;/h3&gt;
&lt;p&gt;&lt;iframe src="https://player.vimeo.com/video/214560619" width="640" height="360" frameborder="0" webkitallowfullscreen mozallowfullscreen allowfullscreen&gt;&lt;/iframe&gt;
&lt;p&gt;&lt;a href="https://vimeo.com/214560619"&gt;虎尾科技大學 機械設計工程系-40423104-W5-單連趕v-rep模擬&lt;/a&gt; from &lt;a href="https://vimeo.com/user44900188"&gt;40423104-Yan syuan&lt;/a&gt; on &lt;a href="https://vimeo.com"&gt;Vimeo&lt;/a&gt;.&lt;/p&gt;&lt;/p&gt;
&lt;h3&gt;Git Hub 改版問題&lt;/h3&gt;
&lt;p&gt;&lt;pre&gt;可進入&lt;a href="https://help.github.com/articles/page-build-failed-tag-not-properly-terminated/"&gt;看解決方法&lt;/pre&gt;
&lt;pre&gt;進入自己倉儲資料夾&lt;/pre&gt;
&lt;a href="http://imgur.com/LzpsaMx"&gt;&lt;img src="http://i.imgur.com/LzpsaMx.png" title="source: imgur.com" /&gt;&lt;/a&gt;
&lt;pre&gt;在 SciTE 下編輯&lt;/pre&gt;
&lt;a href="http://imgur.com/bAvaxEU"&gt;&lt;img src="http://i.imgur.com/bAvaxEU.png" title="source: imgur.com" /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;將所有"{"改成"{{"，以下為修改後的程式碼&lt;/pre&gt;

&lt;pre&gt;# Liquid-style Tags
*Author: Jake Vanderplas &lt;jakevdp@cs.washington.edu&gt;*

This plugin allows liquid-style tags to be inserted into markdown within
Pelican documents. Liquid uses tags bounded by ``{{% ... %}}``, and is used
to extend markdown in other blogging platforms such as octopress.

This set of extensions does not actually interface with liquid, but allows
users to define their own liquid-style tags which will be inserted into
the markdown preprocessor stream.  There are several built-in tags, which
can be added as follows.

First, in your pelicanconf.py file, add the plugins you want to  use:

    PLUGIN_PATH = '/path/to/pelican-plugins'
    PLUGINS = ['liquid_tags.img', 'liquid_tags.video',
               'liquid_tags.youtube', 'liquid_tags.vimeo',
               'liquid_tags.include_code', 'liquid_tags.notebook']

There are several options available

## Image Tag
To insert a sized and labeled image in your document, enable the
``liquid_tags.img`` plugin and use the following:

    {{% img [class name(s)] path/to/image [width [height]] [title text | "title text" ["alt text"]] %}}

### Base64 Image (inline image) tag

There is one more tag for image: ``b64img``. It is based on ``img`` tag, but instead of inserting link on image it acutally reads image and inserts it as base64 text into ``&lt;img src=`` attribute.

To use it:

1. Enable ``liquid_tags.b64img``
1. Insert tag as you'd insert image one: ``{{% b64img [class name(s)] path/to/image [width [height]] [title text | "title text" ["alt text"]] %}}``

Images are read on compilation phase so you can use any local path (just be sure that image will remain there on next compilation)

## Instagram Tag
To insert a sized and labeled Instagram image in your document by its shortcode (such as ``pFI0CAIZna``), enable the ``liquid_tags.gram`` plugin and use the following:

    {{% gram shortcode [size] [width] [class name(s)] [title text | "title text" ["alt text"]] %}}

You can specify a size with `t`, `m`, or `l`.

## Flickr Tag
To insert a Flickr image to a post, follow these steps:

1. Enable ``liquid_tags.flickr``
2. [Get an API key from Flickr](https://www.flickr.com/services/apps/create/apply)
3. Add FLICKR_API_KEY to your config
4. Add this to your document:

    ``{{% flickr image_id [small|medium|large] ["alt text"|'alt text'] %}}``

## Giphy Tag
To insert a gif from Giphy in your document by its id (such as ``aMSJFS6oFX0fC``), enable the ``liquid_tags.giphy`` plugin and use the following:

    {{% giphy gif_id ["alt text"|'alt text'] %}}

IMPORTANT: You have to request a production API key from giphy [here](https://api.giphy.com/submit).
For the first runs you could also use the public beta key you can get [here](https://github.com/giphy/GiphyAPI).

## Soundcloud Tag
To insert a Soundcloud Widget to a post, follow these steps:

1. Enable ``liquid_tags.soundcloud``
2. Add this to your document:

    ``{{% soundcloud track_url %}}``

## Youtube Tag
To insert youtube video into a post, enable the
``liquid_tags.youtube`` plugin, and add to your document:

    {{% youtube youtube_id [width] [height] %}}

The width and height are in pixels, and can be optionally specified.  If they
are not, then the dimensions will be 640 (wide) by 390 (tall).

If you're experiencing issues with code generating (i.e. missing closing tags), add `SUMMARY_MAX_LENGTH = None` to your config.

## Vimeo Tag
To insert a Vimeo video into a post, enable the
``liquid_tags.vimeo`` plugin, and add to your document:

    {{% vimeo vimeo_id [width] [height] %}}

The width and height are in pixels, and can be optionally specified.  If they
are not, then the dimensions will be 640 (wide) by 390 (tall).

If you're experiencing issues with code generating (i.e. missing closing tags), add `SUMMARY_MAX_LENGTH = None` to your config.

## Video Tag
To insert flash/HTML5-friendly video into a post, enable the
``liquid_tags.video`` plugin, and add to your document:

    {{% video /url/to/video.mp4 [width] [height] [/path/to/poster.png] %}}

The width and height are in pixels, and can be optionally specified.  If they
are not, then the original video size will be used.  The poster is an image
which is used as a preview of the video.

To use a video from file, make sure it's in a static directory and put in
the appropriate url.

## Audio Tag
To insert HTML5 audio into a post, enable the ``liquid_tags.audio`` plugin,
and add to your document:

    {{% audio url/to/audio [url/to/audio] [url/to/audio] %}}

Up to 3 audio urls are possible. So you can add different versions of
the audio file you want to post because not every browser support every
file format.

To use a audio from file, make sure it's in a static directory and put in
the appropriate url.

## Include Code
To include code from a file in your document with a link to the original
file, enable the ``liquid_tags.include_code`` plugin, and add to your
document:

    {{% include_code /path/to/code.py [lang:python] [lines:X-Y] [:hidefilename:] [title] %}}

All arguments are optional but their order must be kept. `:hidefilename:` is
only allowed if a title is also given.

    {{% include_code /path/to/code.py lines:1-10 :hidefilename: Test Example %}}

This example will show the first 10 lines of the file while hiding the actual
filename.

The script must be in the ``code`` subdirectory of your content folder:
this default location can be changed by specifying

    CODE_DIR = 'code'

within your configuration file. Additionally, in order for the resulting
hyperlink to work, this directory must be listed under the STATIC_PATHS
setting, e.g.:

    STATIC_PATHS = ['images', 'code']

## IPython notebooks

To insert an [IPython][] notebook into your post, enable the
``liquid_tags.notebook`` plugin and add to your document:

    {{% notebook filename.ipynb %}}

The file should be specified relative to the ``notebooks`` subdirectory of the
content directory.  Optionally, this subdirectory can be specified in the
config file:

    NOTEBOOK_DIR = 'notebooks'

Because the conversion and rendering of notebooks is rather involved, there
are a few extra steps required for this plugin:

- First, you will need to install IPython:

      pip install ipython==2.4.1

- After typing "make html" when using the notebook tag, a file called
  ``_nb_header.html`` will be produced in the main directory.  The content
  of the file should be included in the header of the theme.  An easy way
  to accomplish this is to add the following lines within the header template
  of the theme you use:

      {{% if EXTRA_HEADER %}}
      {{ EXTRA_HEADER }}
      {{% endif %}}

  and in your configuration file, include the line:

      EXTRA_HEADER = open('_nb_header.html').read().decode('utf-8')

  this will insert the proper css formatting into your document.

### Optional Arguments for Notebook Tags

The notebook tag also has two optional arguments: ``cells`` and ``language``.

- You can specify a slice of cells to include:

  ``{{% notebook filename.ipynb cells[2:8] %}}``

- You can also specify the name of a language which Pygments should use for
  highlighting code cells. A list of the short names for languages that Pygments
  will highlight can be found [here](http://www.pygments.org/docs/lexers/).

  ``{{% notebook filename.ipynb language[julia] %}}``

  This may be helpful for those using [IJulia](https://github.com/JuliaLang/IJulia.jl)
  or notebooks in any other language, especially as the IPython project [broadens its
  scope](https://github.com/ipython/ipython/wiki/Roadmap:-IPython) of [language
  compatibility](http://jupyter.org/). By default, the language for highlighting
  will be ``ipython``.

- These options can be used separately, together, or not at all. However,
  if both tags are used then ``cells`` must come before ``language``:

  ``{{% notebook filename.ipynb cells[2:8] language[julia] %}}``

### Collapsible Code in IPython Notebooks

The plugin also enables collapsible code input boxes. For this to work
you first need to copy the file ``pelicanhtml_3.tpl`` (for IPython
3.x, ``pelicanhtml_2.tpl`` (for IPython 2.x)...) to the top level of your
Pelican blog. Notebook input cells containing the comment line ``#
&lt;!-- collapse=True --&gt;`` will be collapsed when the html page is
loaded and can be expanded by clicking on them. Cells containing the
comment line ``# &lt;!-- collapse=False --&gt;`` will be open on load but
can be collapsed by clicking on their header. Cells without collapse
comments are rendered as standard code input cells.

## Testing

To test the plugin in multiple environments we use [tox](http://tox.readthedocs.org/en/latest/), to run the entire test suite, just type:


 wzxhzdk:0 


[IPython]: http://ipython.org/&lt;/pre&gt;

&lt;h3&gt;心得&lt;/h3&gt;
&lt;p&gt;&lt;p&gt;1.透過多次練習越來越熟悉v-rep的模擬操作&lt;/p&gt;
&lt;p&gt;2.清楚多連桿與單連桿機構&lt;/p&gt;
&lt;p&gt;3.了解連桿運動方式 &lt;/p&gt;
&lt;p&gt;4.熟悉解決Git Hub改版方法&lt;/p&gt;&lt;/p&gt;</summary><category term="V-rep-W5"></category></entry><entry><title>W4-Hyperworks 與 2D 繪圖</title><link href="./Hyperworks.html" rel="alternate"></link><published>2017-03-16T15:00:00+08:00</published><updated>2017-03-16T15:00:00+08:00</updated><author><name>40423104-YanSyuan</name></author><id>tag:,2017-03-16:./Hyperworks.html</id><summary type="html">&lt;h4&gt;網際平面四連桿機構動態模擬&lt;/h4&gt;
&lt;h4&gt;單連桿繪製與導入V-rep&lt;/h4&gt;
&lt;h4&gt;Hyperworks安裝&lt;/h4&gt;


&lt;h3&gt;網際平面四連桿機構動態模擬&lt;/h3&gt;
&lt;h4&gt;四連桿平面機構&lt;/h4&gt;
&lt;!-- 導入 Brython 標準程式庫 3.3.1 --&gt;

&lt;script type="text/javascript" src="./../data/brython_dist.js"&gt;
&lt;/script&gt;

&lt;script type="text/javascript" src="./../data/Cango-8v05-min.js"&gt;&lt;/script&gt;

&lt;script type="text/javascript" src="./../data/Cango2D-7v04-min.js"&gt;&lt;/script&gt;

&lt;script type="text/javascript" src="./../data/CangoAnimation-4v01.js"&gt;&lt;/script&gt;

&lt;!-- 啟動 Brython 時, 設定 pythonpath 為 data/py --&gt;

&lt;script&gt;
window.onload=function(){
brython({debug:1, pythonpath:['./../data/py']});
}
&lt;/script&gt;

&lt;!-- 以下執行 Brython 程式 --&gt;

&lt;p&gt;平面機構繪圖:&lt;/p&gt;
&lt;!-- 以下執行 Brython 程式 --&gt;

&lt;canvas id="plotarea2" width="600" height="400"&gt;&lt;/canvas&gt;

&lt;script type="text/python"&gt;
from browser import window

cango = window.Cango2D.new
shapedefs = window.shapeDefs
obj2d = window.Obj2D.new
group2d = window.Group2D.new
cgo = cango("plotarea2")

x1, y1 = 40, 40
cx1, cy1 = 60, 100
x2, y2 = 130, 110
cx2, cy2 = 120, 110
cx3, cy3 = 140, 40
x3, y3 = 120, 90

def dragC1(mousePos):
    global cx1, cy1
    cx1 = mousePos.x
    cy1 = mousePos.y
    drawCurve()

def dragC2(mousePos):
    global cx2, cy2
    cx2 = mousePos.x
    cy2 = mousePos.y
    drawCurve()

def dragC3(mousePos):
    global cx3, cy3
    cx3 = mousePos.x
    cy3 = mousePos.y
    drawCurve()

def dragX1(mousePos):
    global x1, y1
    x1 = mousePos.x
    y1 = mousePos.y
    drawCurve()

def drawCurve():
    # curve change shape so it must be re-draw each time
    # draw a quadratic bezier from x1,y2 to x2,y2
    qbez = obj2d(['M', x1, y1, 'Q', cx1, cy1, x2, y2], "PATH",  {
          "strokeColor":'blue'})
    cbez = obj2d(['M', x2, y2, 'C', cx2, cy2, cx3, cy3, x3, y3], "PATH",  {
          "strokeColor":'green'})
    # show lines to control point
    '''
    L1 = obj2d(['M', x1, y1, 'L', cx1, cy1, x2, y2], "PATH", {
      "strokeColor":"rgba(0, 0, 0, 0.2)",
      "dashed":[4]})  # semi-transparent gray
    L2 = obj2d(['M', x2, y2, 'L', cx2, cy2], "PATH", {
      "strokeColor":"rgba(0, 0, 0, 0.2)",
      "dashed":[4]})
    L3 = obj2d(['M', x3, y3, 'L', cx3, cy3], "PATH", {
      "strokeColor":"rgba(0, 0, 0, 0.2)",
      "dashed":[4]})
    '''
    L1 = obj2d(['M', x1, y1, 'L', cx1, cy1], "PATH", {
      "strokeColor":"rgba(0, 0, 0, 0.2)",
      "solided":[10]})  # semi-transparent gray
    L2 = obj2d(['M', cx1, cy1, 'L', cx2, cy2], "PATH", {
      "strokeColor":"rgba(0, 0, 0, 0.2)",
      "solided":[10]})
    L3 = obj2d(['M', cx2, cy2, 'L', cx3, cy3], "PATH", {
      "strokeColor":"rgba(0, 0, 0, 0.2)",
      "solided":[10]})
    #c1.transform.reset()
    c1.transform.translate(cx1, cy1)
    #c2.transform.reset()
    c2.transform.translate(cx2, cy2)
    #c3.transform.reset()
    c3.transform.translate(cx3, cy3)
    #mx1.transform.reset()
    mx1.transform.translate(x1, y1)
    #grp = group2d(qbez, cbez, L1, L2, L3, c1, c2, c3)
    grp = group2d(L1, L2, L3, c1, c2, c3, mx1)
    cgo.clearCanvas()
    cgo.render(grp)

cgo.clearCanvas("lightyellow")
cgo.setWorldCoords(0, 0, 200)

# draggable control points
c1 = obj2d(shapedefs.circle(4), "SHAPE", {"fillColor":'red'})
c1.enableDrag(None, dragC1, None)
c2 = c1.dup()
c2.enableDrag(None, dragC2, None)
c3 = c1.dup()
c3.enableDrag(None, dragC3, None)
mx1 = c1.dup()
mx1.enableDrag(None, dragX1, None)
drawCurve();
&lt;/script&gt;

&lt;p&gt;機械手臂動態模擬:&lt;/p&gt;
&lt;canvas id='robot' width='800' height='400'&gt;&lt;/canvas&gt;

&lt;script type="text/python"&gt;
from browser import window

cango2d = window.Cango2D.new
shapedefs = window.shapeDefs
obj2d = window.Obj2D.new
tweener = window.Tweener.new

cgo = cango2d("robot")
# 清除畫面
cgo.clearCanvas("lightyellow")
cgo.setWorldCoords(-50, -50, 300)

# 加上基軸與第一桿
# 畫筆移到 -20, -10, 畫直線到 -10,-10 以及 -10,0 
standData = ['M', -20,-10, 'L', -10,-10, -10,0, 'A', 10,10,0,0,0,10,0, 'L',10,-10, 20,-10, 20,-40, -20,-40,'z']
stand = obj2d(standData, "SHAPE", {
        "fillColor":'darkgray',
        "border": True,
        "strokeColor": "#222222" })
axle0 = obj2d(shapedefs.circle(10), "SHAPE", {
        "fillColor":'gray',
        "border": True,
        "strokeColor": "#222222" })
armGrp = cgo.createGroup2D(stand, axle0)

segData = ['M',0,-8, 'A',8,8,0,0,0,0,8, 'L',50,8, 'A',8,8,0,0,0,50,-8, 'Z']
seg1 = obj2d(segData, "SHAPE", {
        "fillColor":'darkGray',
        "border": True,
        "strokeColor": "#222222",
        "zIndex": -1 })
# 利用 zIndex 決定疊層的先後次序
axle1 = obj2d(shapedefs.circle(8), "SHAPE", {
        "fillColor":'gray',
        "border": True,
        "strokeColor": "#222222",
        "zIndex": 1 })
axle1.translate(50, 0)
seg1Grp = cgo.createGroup2D(seg1, axle1)
armGrp.addObj(seg1Grp)

# 加上第二軸
seg2 = obj2d(segData, "SHAPE", {
        "fillColor":'darkGray',
        "border": True,
        "strokeColor": "#222222",
        "zIndex": -1 })
axle2 = obj2d(shapedefs.circle(8), "SHAPE", {
        "fillColor":'gray',
        "border": True,
        "strokeColor": "#222222",
        "zIndex": 1 })
axle2.translate(50, 0)
seg2Grp = cgo.createGroup2D(seg2, axle2)
cgo.render(seg2Grp)
# 請注意 seg2Grp 加上 seg1Grp 物件上
seg1Grp.addObj(seg2Grp)

seg3 = obj2d(segData, "SHAPE", {
        'fillColor':'darkGray',
        'border': True,
        'strokeColor': "#222222",
        'zIndex': -1 })
axle3 = obj2d(shapedefs.circle(6), "SHAPE", {
        'fillColor':'gray',
        'border': True,
        'strokeColor': "#222222",
        'zIndex': 1 })
axle3.translate(50, 0)
seg3Grp = cgo.createGroup2D(seg3, axle3)
seg2Grp.addObj(seg3Grp)

seg4Data = ['M',0,-6, 'A',6,6,0,0,0,0,6, 'L',40,6, 40,12, 50,12, 50,-12, 40,-12, 40,-6, 'Z']
seg4 = obj2d(seg4Data, "SHAPE", {
        'fillColor':'darkGray',
        'border': True,
        'strokeColor': "#222222",
        'zIndex': -1 })
seg3Grp.addObj(seg4)

# setup animation
animData = {'s1': [0, 80, 45, 0],
                  's2': [0, -60, -60, 0],
                  's3': [0, -90, 0, 90, 0],
                  's4': [0, 30, -90, 0]}

armTwnr = tweener(0, 3500, 'loop')

def initArm(opts):
    seg2Grp.transform.translate(50,0)
    seg3Grp.transform.translate(50,0)
    seg4.transform.translate(50,0)


def armPathFn(time, opts):
    seg1Rot = armTwnr.getVal(time, opts.s1)
    seg2Rot = armTwnr.getVal(time, opts.s2)
    seg3Rot = armTwnr.getVal(time, opts.s3)
    seg4Rot = armTwnr.getVal(time, opts.s4)

    seg1Grp.transform.rotate(seg1Rot)
    seg2Grp.transform.rotate(seg2Rot)
    seg2Grp.transform.translate(50,0)
    seg3Grp.transform.rotate(seg3Rot)
    seg3Grp.transform.translate(50,0)
    seg4.transform.rotate(seg4Rot)
    seg4.transform.translate(50,0)

cgo.animate(armGrp, initArm, armPathFn, animData)
cgo.playAnimation()
&lt;/script&gt;

&lt;h3&gt;單連桿繪製與導入V-rep&lt;/h3&gt;
&lt;p&gt;&lt;p&gt; 利用Solvespace繪製以下尺寸及組裝連桿&lt;/p&gt;&lt;/p&gt;
&lt;h4&gt;尺寸&lt;/h4&gt;
&lt;p&gt;&lt;a href="http://imgur.com/pQ7GYmG"&gt;&lt;img src="http://i.imgur.com/pQ7GYmG.jpg" title="source: imgur.com" /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h4&gt;長度30連桿&lt;/h4&gt;
&lt;p&gt;&lt;iframe src="https://player.vimeo.com/video/209355096" width="640" height="343" frameborder="0" webkitallowfullscreen mozallowfullscreen allowfullscreen&gt;&lt;/iframe&gt;&lt;/p&gt;
&lt;h4&gt;長度50連桿&lt;/h4&gt;
&lt;p&gt;&lt;iframe src="https://player.vimeo.com/video/209354247" width="640" height="360" frameborder="0" webkitallowfullscreen mozallowfullscreen allowfullscreen&gt;&lt;/iframe&gt;&lt;/p&gt;
&lt;h4&gt;直徑5的連桿&lt;/h4&gt;
&lt;p&gt;&lt;iframe src="https://player.vimeo.com/video/209355724" width="640" height="360" frameborder="0" webkitallowfullscreen mozallowfullscreen allowfullscreen&gt;&lt;/iframe&gt;&lt;/p&gt;
&lt;h4&gt;導入V-rep&lt;/h4&gt;
&lt;p&gt;&lt;iframe src="https://player.vimeo.com/video/209373893" width="640" height="360" frameborder="0" webkitallowfullscreen mozallowfullscreen allowfullscreen&gt;&lt;/iframe&gt;&lt;/p&gt;
&lt;h4&gt;V-rep模擬&lt;/h4&gt;
&lt;p&gt;&lt;iframe src="https://player.vimeo.com/video/210707261" width="640" height="360" frameborder="0" webkitallowfullscreen mozallowfullscreen allowfullscreen&gt;&lt;/iframe&gt;&lt;/p&gt;
&lt;h2&gt;Hyperworks安裝心得&lt;/h2&gt;
&lt;p&gt;因為安裝時間上需要花比較多時間，所以沒有錄製影片，操作過後與網路上的影片的介紹，我發現HyperWorks包括建模，線性和非線性分析，結構和系統級優化，流​​體和多體動力學模擬，電磁兼容性（EMC），多物理場分析，基於模型的開發和數據管理解決等功能，對於未來的幫助很大，讓我對於這個軟體有新認識與期待。&lt;/p&gt;
&lt;h3&gt;心得&lt;/h3&gt;
&lt;p&gt;&lt;p&gt;1.學習與複習以線及座標繪製四連桿&lt;/p&gt;
&lt;p&gt;2.單連桿繪製練習與模擬&lt;/p&gt;
&lt;p&gt;3. 大約讀懂一些機械手臂動態模擬的程式與做動方式&lt;/p&gt;&lt;/p&gt;</summary><category term="Hyperworks 與 2D 繪圖-W4"></category></entry><entry><title>W3-Fossil 與 Stunnel 啟動</title><link href="./Fossil%20%E8%88%87%20Stunnel.html" rel="alternate"></link><published>2017-03-09T16:00:00+08:00</published><updated>2017-03-09T16:00:00+08:00</updated><author><name>40423104-YanSyuan</name></author><id>tag:,2017-03-09:./Fossil 與 Stunnel.html</id><summary type="html">&lt;h4&gt;Fossil SCM與Stunnel 啟動&lt;/h4&gt;
&lt;h4&gt;Hyperworks翻譯&lt;/h4&gt;
&lt;h4&gt;Solvespace四連桿三角形頂點運動軌跡&lt;/h4&gt;


&lt;h2&gt;Fossil SCM與Stunnel 啟動&lt;/h2&gt;
&lt;h4&gt;步驟1. 執行fossil_repo目錄執行指令&lt;/h4&gt;
&lt;p&gt;&lt;pre&gt;fossil init 組別.fossil&lt;/pre&gt;
&lt;a href="http://imgur.com/lxR6Cpe"&gt;&lt;img src="http://i.imgur.com/lxR6Cpe.jpg" title="source: imgur.com" /&gt;&lt;/a&gt;
&lt;a href="http://imgur.com/nxL7g4L"&gt;&lt;img src="http://i.imgur.com/nxL7g4L.jpg" title="source: imgur.com" /&gt;&lt;/a&gt;
&lt;p&gt;*帳號密碼記得儲存&lt;/p&gt;&lt;/p&gt;
&lt;h3&gt;步驟2. 更改Start.bat內容(在SciTE下更改)&lt;/h3&gt;
&lt;p&gt;&lt;pre&gt;
REM tiny2017 主要針對初學 Python3 與 C 學員所建立
REM 近端使用 fossil 管理資料版本, 並且定時轉為 git 格式後上傳到 github
@echo off
REM 設定 y 硬碟代號與 data 目錄對應
set Disk=y
subst %Disk%: "data"
REM 設定 leo 相關對應 Home 位置
set HomePath=%Disk%:\home
set HomeDrive=%Disk%:\home
set Home=%Disk%:\home
REM 將系統 Python 程式的 io 設為 utf-8
set PYTHONIOENCODING="utf-8"
REM 將後續的指令執行, 以 %Disk% 為主
%Disk%:
REM 設定 PYTHONPATH
set PYTHONPATH=%Disk%:\python-3.5.3-embed-amd64
REM 設定 Leo 所用的編輯器
set LEO_EDITOR=%Disk%:\wscite\SciTE.exe
REM for fossil https 連線設定
set HTTPS=on
REM 指令搜尋路徑設定
set path1=%PATH%;%Disk%:;%Disk%:\python-3.5.3-embed-amd64;%Disk%:\git\bin;%Disk%:\stunnel\bin;%Disk%:\sqlite-tools;%Disk%:\python-3.5.3-embed-amd64\Scripts;%Disk%:\portablegit\bin;
set path2=c:\Windows\Microsoft.NET\Framework\v3.5;%Disk%:\python-3.5.3-embed-amd64\Lib\site-packages;
path=%path%;%path1%;%path2%
start /MIN %Disk%:\wscite\SciTE.exe
start /MIN cmd.exe
start /MIN cmd.exe
start /MIN cmd.exe
REM 啟動 Leo 編輯器
REM %Disk%:\Miniconda3\python.exe %Disk%:\apps\launchLeo.py
REM 啟動 stunnel
start /MIN fossil.exe server -P 127.0.0.1:8080 %Disk%:\tmp\fossil_repo\2017springcd_hw.fpssil
REM 取得電腦 IP, 然後設定 %Disk%:/stunnel/config/stunnel.conf
for /f "delims=[] tokens=2" %%a in ('ping -4 -n 1 %ComputerName% ^| findstr [') do set NetworkIP=%%a
REM echo Network IP: %NetworkIP%
REM Saved in %Disk%:\stunnel\config\stunnel.conf
@echo off
REM 建立 stunnel.conf
@echo [https] &amp;gt; %Disk%:\stunnel\config\stunnel.conf
REM 附加資料
@echo accept = %NetworkIP%:443 &amp;gt;&amp;gt; %Disk%:\stunnel\config\stunnel.conf
@echo connect = 127.0.0.1:8080 &amp;gt;&amp;gt; %Disk%:\stunnel\config\stunnel.conf
@echo TIMEOUTclose = 0 &amp;gt;&amp;gt; %Disk%:\stunnel\config\stunnel.conf
@echo cert = %Disk%:\stunnel\config\localhost.crt &amp;gt;&amp;gt; %Disk%:\stunnel\config\stunnel.conf
@echo key = %Disk%:\stunnel\config\localhost.key &amp;gt;&amp;gt; %Disk%:\stunnel\config\stunnel.conf
REM 啟動 stunnel
start /MIN stunnel.exe
Exit
&lt;/pre&gt;
&lt;p&gt;*記得要儲存&lt;/p&gt;&lt;/p&gt;
&lt;h4&gt;步驟3. 執行查詢IP指令(如有使用proxy，記得先關閉)&lt;/h4&gt;
&lt;p&gt;&lt;pre&gt;ipconfig /all&lt;/pre&gt;
&lt;a href="http://imgur.com/uKh1Dq3"&gt;&lt;img src="http://i.imgur.com/uKh1Dq3.png" title="source: imgur.com" /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h4&gt;步驟4. 將查詢到的IPv4&lt;/h4&gt;
&lt;p&gt;&lt;pre&gt;在網頁上輸入 https://IP位址 &lt;/pre&gt;&lt;/p&gt;
&lt;h4&gt;完成&lt;/h4&gt;
&lt;p&gt;&lt;a href="http://imgur.com/k7r1XRG"&gt;&lt;img src="http://i.imgur.com/k7r1XRG.png" title="source: imgur.com" /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h4&gt;可在網頁中進入設定更改成自己小組的名字&lt;/h4&gt;
&lt;h2&gt;操作影片&lt;/h2&gt;
&lt;p&gt;&lt;iframe src="https://player.vimeo.com/video/207569135" width="640" height="360" frameborder="0" webkitallowfullscreen mozallowfullscreen allowfullscreen&gt;&lt;/iframe&gt;&lt;/p&gt;
&lt;h2&gt;hyperworks翻譯&lt;/h2&gt;
&lt;p&gt;&lt;h2&gt;Hyperworks1&lt;/h2&gt;&lt;/p&gt;
&lt;iframe src="https://player.vimeo.com/video/207229473" width="640" height="360" frameborder="0" webkitallowfullscreen mozallowfullscreen allowfullscreen&gt;&lt;/iframe&gt;

&lt;h3&gt;逐字稿&lt;/h3&gt;

&lt;p&gt;In the 2017 release, we followed our vision and implement a lot more features, delivering more technology for your HyperWorks units investment.&lt;/p&gt;

&lt;p&gt;在2017年版本中，我們遵循了我們的願景並實施了更多功能，為您的HyperWorks提供更多技術。&lt;/p&gt;

&lt;p&gt;In our continuous development, we focused, as# always, on simulation-driven innovation, adding more optimization technology. &lt;/p&gt;

&lt;p&gt;在我們的不斷發展中，我們一如既往地專注於模擬驅動的創新，增加更多的優化技術。&lt;/p&gt;

&lt;p&gt;We added more physics simulation to the software, and we improved our parallel performance on high performance computers. &lt;/p&gt;

&lt;p&gt;我們增加了許多的物理的模擬，我們提高了高性能電腦的平行性能。&lt;/p&gt;

&lt;p&gt;OptiStruct, which is our implicit code, adds a lot of development in the nonlinear implicit area, but also in the optimization technology.&lt;/p&gt;

&lt;p&gt;OptiStruct是我們的隱式代碼，在非線性隱含區域中，也在優化技術中添加了很多開發。&lt;/p&gt;

&lt;p&gt;RADIOSS, we see a lot of development in new materials and material modeling. &lt;/p&gt;

&lt;p&gt;RADIOSS，我們看到很多新材料和材料建模的發展。&lt;/p&gt;

&lt;p&gt;You probably know that we did the acquisition of MDS a couple of years back, and we have now MDS integrated with RSDIOSS, and are doing application there.&lt;/p&gt;

&lt;p&gt;您可能知道我們在幾年前就完成了MDS的收購，現在我們已經將MDS與RSDIOSS整合，並開始應用。&lt;/p&gt;

&lt;p&gt;MotionSolve is based on a very unique formulation that this different from other multibody dynamics code, and the  formulation lends itself very well to optimization implementation.&lt;/p&gt;

&lt;p&gt;MoMotionSolvetionSolve是根據一個非常獨特的公式，這不同於其他多體動力學代碼，MotionSolve公式本身非常好地優化實施。 &lt;/p&gt;

&lt;p&gt;So the team has worked really hard on contact formulations, got very robust.&lt;/p&gt;

&lt;p&gt;因此團隊對於接觸公式非常努力，獲得了非常強大的。&lt;/p&gt;

&lt;p&gt;It's very cool which kind of problems can solve with contact modelling.&lt;/p&gt;

&lt;p&gt;這類型的問題可以解決與接觸建模這是非常酷的。&lt;/p&gt;

&lt;p&gt;So this is along the structural solvers side on AcuSolve side we actually added the complete portfolio of turbulence and transition models that really helps us to solve problems in wind turbines and automotive industry much more accurately, and it’s a big asset of physics simulation.&lt;/p&gt;

&lt;p&gt;因此，這是沿著AcuSolve一側的結構解算方面，我們實際添加了完整的湍流和轉換模型組合，真正幫助我們更準確地解決風力渦輪機和汽車行業的問題，這是物理仿真的一個重要的資產。&lt;/p&gt;

&lt;p&gt;And then our electromagnetic suite has actually grown last year through the acquisition of Flux, from the CEDRAT company.&lt;/p&gt;

&lt;p&gt;然後，我們的電磁套件實際上是去年通過從CEDRAT公司收購Flux而實現的。&lt;/p&gt;

&lt;p&gt;As well as the acquisition of WinProp, from AWE.&lt;/p&gt;

&lt;p&gt;以及從AWE收購WinProp。&lt;/p&gt;

&lt;p&gt;So now we have a complete frequency spectrum from low frequency electromagnetics the high frequency electromagnetics which is powered by FEKO.&lt;/p&gt;

&lt;p&gt;所以現在我們有一個完整的頻譜從低頻電磁學的高頻電磁學由FEKO供電。&lt;/p&gt;

&lt;p&gt;We now have a complete portfolio of physics modeling available for our customers, and it’s all linked through optimization. &lt;/p&gt;

&lt;p&gt;我們現在有一個完整的物理建模組合可用於我們的客戶，它都通過優化鏈接。&lt;/p&gt;

&lt;h2&gt;Hyperworks3&lt;/h2&gt;

&lt;iframe src="https://player.vimeo.com/video/207229503" width="640" height="360" frameborder="0" webkitallowfullscreen mozallowfullscreen allowfullscreen&gt;&lt;/iframe&gt;

&lt;h3&gt;逐字稿&lt;/h3&gt;

&lt;p&gt;In OptiStruct, one of our focus areas is nonlinear large deformation analysis.&lt;/p&gt;

&lt;p&gt;在OptiStruct中，我們的一個重點領域是非線性大變形分析。 &lt;/p&gt;

&lt;p&gt;And in 2017 we added nonlinear transient analysis.&lt;/p&gt;

&lt;p&gt;在2017年，我們添加了非線性瞬態分析&lt;/p&gt;

&lt;p&gt;The main purpose was to couple AcuSolve to do fluid-structure interaction.&lt;/p&gt;

&lt;p&gt;主要目的是使AcuSolve與流體 - 結構相互作用。&lt;/p&gt;

&lt;p&gt;But also one development that happened during the last year came out piece-wise in different point releases and is now really mature.&lt;/p&gt;

&lt;p&gt;但是，在過去一年中發生的一個發展，在不同的積分發布中分段出現，現在已經成熟。&lt;/p&gt;

&lt;p&gt;And 2017 is our contact analysis, so we have different ways of defining sliding contact and things like that.&lt;/p&gt;

&lt;p&gt;2017年是我們的接觸分析，所以我們有不同的方式來定義滑動接觸和類似的東西。&lt;/p&gt;

&lt;p&gt;The fast contact analysis for small deformation is blazing fast.&lt;/p&gt;

&lt;p&gt;對小變形的快速接觸分析是快速的。&lt;/p&gt;

&lt;p&gt;It’s a very simple idea that makes the solution very fast, and that adds OptiStruct as really a leading nonlinear structural solver. &lt;/p&gt;

&lt;p&gt;這是一個非常簡單的想法，使解決方案非常快，並將OptiStruct添加為真正的領先的非線性結構求解器。&lt;/p&gt;

&lt;p&gt;Our two major optimization packages are OptiStruct for structural optimization, there’s a huge multidisciplinary component, too.&lt;/p&gt;

&lt;p&gt;我們的兩個主要優化包是用於結構優化的OptiStruct，還有一個巨大的多學科組件。&lt;/p&gt;

&lt;p&gt;And Hyperstudy for general optimization wrap around multidisciplinary optimization.&lt;/p&gt;

&lt;p&gt;並且Hyperstudy對一般優化包圍多學科優化。&lt;/p&gt;

&lt;p&gt;OptiStruct we spend a lot of time continuing the development for optimization and we have now Failsafe topology optimization.&lt;/p&gt;

&lt;p&gt;OptiStruct我們花了很多時間繼續開發優化，我們現在已經失效的拓撲優化。&lt;/p&gt;

&lt;p&gt;We kept on working on the manufacturing solution to do lattice optimization.&lt;/p&gt;

&lt;p&gt;我們一直在製造解決方案上做晶格優化。&lt;/p&gt;

&lt;p&gt;For the multi-model optimization it’s really maturing and we find more and more applications where that helps. &lt;/p&gt;

&lt;p&gt;對於多模型優化，它真的成熟，我們發現越來越多的應用程序，這有助於。&lt;/p&gt;

&lt;p&gt;Our goal is actually to include all the physics in the optimizations.&lt;/p&gt;

&lt;p&gt;我們的目標實際上是在優化中包括所有的物理。&lt;/p&gt;

&lt;p&gt;So the team right now is working on optimization for nonlinear problems and so on.&lt;/p&gt;

&lt;p&gt;所以團隊現在正在努力優化非線性問題等等。&lt;/p&gt;

&lt;p&gt;And then Hyperstudy, on the other hand, is going through a new transformation of the user the user experience was changed a few years back, but we are now trying to  make it much more easy to use by hiding a lot of the advanced functionalities to the regular users.&lt;/p&gt;

&lt;p&gt;另一方面，Hyperstudy正在經歷用戶體驗在幾年前改變的用戶體驗的一個新的轉變，但是我們現在試圖通過隱藏許多高級功能來使它更容易使用 普通用戶。&lt;/p&gt;

&lt;p&gt;And depending on the level of expertise or depending on the job that the user has to do, they can customize the user experience.&lt;/p&gt;

&lt;p&gt;並且取決於專業水平或者根據用戶必須做的工作，他們可以定制用戶體驗。&lt;/p&gt;

&lt;p&gt;We adds a few new connections.&lt;/p&gt;

&lt;p&gt;我們添加了一些新的連接。&lt;/p&gt;

&lt;p&gt;One of them is a Flux connection.&lt;/p&gt;

&lt;p&gt;其中一個是Flux連接。&lt;/p&gt;

&lt;p&gt;Flux is an electromagnetics code that we just acquired for low frequency electromagnetics, so we can all take a Flux database and put it into Hyperstudy into the study with that.&lt;/p&gt;

&lt;p&gt;Flux是我們剛剛為低頻電磁學採集的電磁學代碼，所以我們可以採用一個Flux數據庫，並把它放入Hyperstudy進行研究。&lt;/p&gt;

&lt;h2&gt;solvespace四連桿三角形頂點運動軌跡&lt;/h2&gt;
&lt;h3&gt;桿件加入三角形顯示路徑與過程&lt;/h3&gt;
&lt;p&gt;&lt;a href="http://imgur.com/9HN7TK8"&gt;&lt;img src="http://i.imgur.com/9HN7TK8.png" title="source: imgur.com" /&gt;&lt;/a&gt;
&lt;iframe src="https://player.vimeo.com/video/208360660" width="640" height="360" frameborder="0" webkitallowfullscreen mozallowfullscreen allowfullscreen&gt;&lt;/iframe&gt;&lt;/p&gt;
&lt;h3&gt;利用excel查看路徑是否與在solvespace操作下相同(驗證路徑)&lt;/h3&gt;
&lt;p&gt;&lt;a href="http://imgur.com/ZraAYID"&gt;&lt;img src="http://i.imgur.com/ZraAYID.png" title="source: imgur.com" /&gt;&lt;/a&gt;
&lt;iframe src="https://player.vimeo.com/video/208361060" width="640" height="360" frameborder="0" webkitallowfullscreen mozallowfullscreen allowfullscreen&gt;&lt;/iframe&gt;&lt;/p&gt;
&lt;h2&gt;V-rep&lt;/h2&gt;
&lt;h3&gt;完成 Solvespace 30-50-60 cm 比例的四連桿組立, 並轉出 stl 檔案, 以 import 方式轉入 V-rep&lt;/h3&gt;
&lt;p&gt;&lt;iframe src="https://player.vimeo.com/video/209081797" width="640" height="347" frameborder="0" webkitallowfullscreen mozallowfullscreen allowfullscreen&gt;&lt;/iframe&gt;&lt;/p&gt;
&lt;h3&gt;利用 Onshape 上述相同尺寸之四連桿機構, 以 stl 轉出 (或其他格式) 後, 再轉入 V-rep&lt;/h3&gt;
&lt;p&gt;&lt;iframe src="https://player.vimeo.com/video/209085492" width="640" height="343" frameborder="0" webkitallowfullscreen mozallowfullscreen allowfullscreen&gt;&lt;/iframe&gt;&lt;/p&gt;
&lt;h2&gt;心得&lt;/h2&gt;
&lt;p&gt;&lt;p&gt; 1.學習如何使用Fossil SCM &lt;/p&gt;
&lt;p&gt; 2.目前Stunnel 啟動不能再proxy下進入網頁 &lt;/p&gt;
&lt;p&gt; 3.英文翻譯學習 及 Hyperworks認識&lt;/p&gt;
&lt;p&gt; 4.熟悉V-rep匯入練習 &lt;/p&gt;&lt;/p&gt;</summary><category term="Fossil 與 Stunnel-W3"></category></entry><entry><title>W2- solvespace四連桿v-rep應用</title><link href="./solvespace%E8%88%87v-rep.html" rel="alternate"></link><published>2017-03-02T11:00:00+08:00</published><updated>2017-03-02T11:00:00+08:00</updated><author><name>40423104-YanSyuan</name></author><id>tag:,2017-03-02:./solvespace與v-rep.html</id><summary type="html">&lt;h4&gt;Solvespace四連桿系統繪圖模擬&lt;/h4&gt;
&lt;h4&gt;v-rep應用模擬&lt;/h4&gt;


&lt;h2&gt;利用Solvespace組合四連桿機構&lt;/h2&gt;
&lt;h3&gt;四連桿機構&lt;/h3&gt;
&lt;iframe src="https://player.vimeo.com/video/206347595" width="640" height="360" frameborder="0" webkitallowfullscreen mozallowfullscreen allowfullscreen&gt;&lt;/iframe&gt;

&lt;h3&gt;長度30連桿&lt;/h3&gt;
&lt;iframe src="https://player.vimeo.com/video/207312630" width="640" height="360" frameborder="0" webkitallowfullscreen mozallowfullscreen allowfullscreen&gt;&lt;/iframe&gt;

&lt;iframe src="./../data/Week2/30桿件.html" width="640" height="360"&gt;&lt;/iframe&gt;

&lt;h3&gt;長度50連桿&lt;/h3&gt;
&lt;iframe src="https://player.vimeo.com/video/207314989" width="640" height="360" frameborder="0" webkitallowfullscreen mozallowfullscreen allowfullscreen&gt;&lt;/iframe&gt;

&lt;iframe src="./../data/Week2/50桿件.html" width="640" height="360"&gt;&lt;/iframe&gt;

&lt;h3&gt;長度60連桿&lt;/h3&gt;
&lt;iframe src="https://player.vimeo.com/video/207315011" width="640" height="360" frameborder="0" webkitallowfullscreen mozallowfullscreen allowfullscreen&gt;&lt;/iframe&gt;

&lt;iframe src="./../data/Week2/60桿件.html" width="640" height="360"&gt;&lt;/iframe&gt;

&lt;h3&gt;四連桿組合&lt;/h3&gt;
&lt;iframe src="https://player.vimeo.com/video/207315023" width="640" height="360" frameborder="0" webkitallowfullscreen mozallowfullscreen allowfullscreen&gt;&lt;/iframe&gt;

&lt;iframe src="./../data/Week2/組合.html" width="640" height="360"&gt;&lt;/iframe&gt;

&lt;h2&gt;v-rep應用&lt;/h2&gt;
&lt;p&gt;&lt;iframe src="https://player.vimeo.com/video/214566863" width="640" height="343" frameborder="0" webkitallowfullscreen mozallowfullscreen allowfullscreen&gt;&lt;/iframe&gt;
&lt;p&gt;&lt;a href="https://vimeo.com/214566863"&gt;虎尾科技大學 機械設計工程系-40423104-W2-V-Rep操作&lt;/a&gt; from &lt;a href="https://vimeo.com/user44900188"&gt;40423104-Yan syuan&lt;/a&gt; on &lt;a href="https://vimeo.com"&gt;Vimeo&lt;/a&gt;.&lt;/p&gt;&lt;/p&gt;
&lt;h2&gt;心得&lt;/h2&gt;
&lt;p&gt;&lt;p&gt; 1.學習v-rep應用模擬四連桿 &lt;/p&gt;
&lt;p&gt; 2.熟悉v-rep操作，由於沒有很熟悉所以在模擬還是有些問題還沒找到解決方法 &lt;/p&gt;
&lt;p&gt; 3.隨著多次練習畫圖模擬，更了解上課內容 &lt;/p&gt;&lt;/p&gt;</summary><category term="solvespace與v-rep-W2"></category></entry><entry><title>W1-協同設計資料與連桿實習</title><link href="./solvespace%E8%88%87Onshape.html" rel="alternate"></link><published>2017-02-23T15:00:00+08:00</published><updated>2017-02-23T15:00:00+08:00</updated><author><name>40423104-YanSyuan</name></author><id>tag:,2017-02-23:./solvespace與Onshape.html</id><summary type="html">&lt;h4&gt;Solvespace 與 Onshape 組立單軸旋轉連桿系統、四連桿系統繪圖模擬&lt;/h4&gt;
&lt;h4&gt;git submodule指令複習&lt;/h4&gt;


&lt;h2&gt;協同設計資料&lt;/h2&gt;
&lt;p&gt;&lt;pre&gt; &lt;/p&gt;
&lt;h4&gt;1.利用 GitHub 建立 2017springcd_hw作業倉儲&lt;/h4&gt;
&lt;h4&gt;2.利用 GitHub 建立 2017springcd_ag2小組倉儲&lt;/h4&gt;
&lt;h4&gt;3.使用 git submodule指令，將組員增加在同一個子目錄&lt;/h4&gt;
&lt;/pre&gt;

&lt;h3&gt;增加子目錄指令:&lt;/h3&gt;
&lt;pre&gt;

&lt;h4&gt;A.→git clone 小組倉儲&lt;/h4&gt;
&lt;h4&gt;B.→cd 倉儲資料夾&lt;/h4&gt;
&lt;h4&gt;C.→git submodule add 子目錄倉儲網址 子目錄名稱&lt;/h4&gt;
&lt;/pre&gt;

&lt;h3&gt;更新子目錄指令:&lt;/h3&gt;
&lt;pre&gt;

&lt;h4&gt;A.git submodule update --init --recursive→抓取原倉儲的子目錄資料&lt;/h4&gt;
&lt;h4&gt;B.git submodule foreach --recursive git pull origin gh-pages→更新所有的子目錄的版本(所有組員都更新) &lt;/pre&gt;&lt;/h4&gt;
&lt;h2&gt;W1任務&lt;/h2&gt;
&lt;p&gt;&lt;pre&gt; &lt;p&gt;1.使用隨身硬碟下載可攜系統，下載&lt;a href="http://service.mde.tw/public/tiny2017_50MB.7z"&gt;tiny2017_50MB.7z&lt;/a&gt;, 以及 &lt;a href="http://service.mde.tw/public/tiny2017_1GB.7z"&gt;tiny2017_1GB.7z&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;2.如何在 tiny2017_1GB.7z 下開起LEO&lt;/p&gt; &lt;/pre&gt;&lt;/p&gt;
&lt;h4&gt;步驟1&lt;/h4&gt;
&lt;p&gt;&lt;a href="http://imgur.com/kFn7kpR"&gt;&lt;img src="http://i.imgur.com/kFn7kpR.jpg" title="source: imgur.com" /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h4&gt;步驟2&lt;/h4&gt;
&lt;p&gt;&lt;a href="http://imgur.com/IlwS7zd"&gt;&lt;img src="http://i.imgur.com/IlwS7zd.jpg" title="source: imgur.com" /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h4&gt;打開完成&lt;/h4&gt;
&lt;p&gt;&lt;a href="http://imgur.com/uLV7Fzb"&gt;&lt;img src="http://i.imgur.com/uLV7Fzb.png" title="source: imgur.com" /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;Solvespace四連桿機構&lt;/h2&gt;
&lt;h3&gt;四連桿機構&lt;/h3&gt;
&lt;iframe src="https://player.vimeo.com/video/206347595" width="640" height="360" frameborder="0" webkitallowfullscreen mozallowfullscreen allowfullscreen&gt;&lt;/iframe&gt;

&lt;h3&gt;長度30連桿&lt;/h3&gt;
&lt;iframe src="https://player.vimeo.com/video/206344876" width="640" height="360" frameborder="0" webkitallowfullscreen mozallowfullscreen allowfullscreen&gt;&lt;/iframe&gt;

&lt;iframe src="./../data/Week1/30桿.html" width="640" height="360"&gt;&lt;/iframe&gt;

&lt;h3&gt;長度50連桿&lt;/h3&gt;
&lt;iframe src="https://player.vimeo.com/video/206346002" width="640" height="360" frameborder="0" webkitallowfullscreen mozallowfullscreen allowfullscreen&gt;&lt;/iframe&gt;

&lt;iframe src="./../data/Week1/50桿.html" width="640" height="360"&gt;&lt;/iframe&gt;

&lt;h3&gt;長度60連桿&lt;/h3&gt;
&lt;iframe src="https://player.vimeo.com/video/206347142" width="640" height="360" frameborder="0" webkitallowfullscreen mozallowfullscreen allowfullscreen&gt;&lt;/iframe&gt;

&lt;iframe src="./../data/Week1/60桿.html" width="640" height="360"&gt;&lt;/iframe&gt;

&lt;h3&gt;四連桿組合&lt;/h3&gt;
&lt;iframe src="https://player.vimeo.com/video/207295299" width="640" height="360" frameborder="0" webkitallowfullscreen mozallowfullscreen allowfullscreen&gt;&lt;/iframe&gt;

&lt;iframe src="./../data/Week1/組合.html" width="640" height="360"&gt;&lt;/iframe&gt;

&lt;h2&gt;Onshape四連桿機構&lt;/h2&gt;
&lt;h3&gt;四連桿機構&lt;/h3&gt;
&lt;p&gt;&lt;iframe src="https://player.vimeo.com/video/207301283" width="640" height="316" frameborder="0" webkitallowfullscreen mozallowfullscreen allowfullscreen&gt;&lt;/iframe&gt;&lt;/p&gt;
&lt;h3&gt;長度30連桿&lt;/h3&gt;
&lt;p&gt;&lt;iframe src="https://player.vimeo.com/video/207300388" width="640" height="316" frameborder="0" webkitallowfullscreen mozallowfullscreen allowfullscreen&gt;&lt;/iframe&gt;&lt;/p&gt;
&lt;h3&gt;長度50連桿&lt;/h3&gt;
&lt;p&gt;&lt;iframe src="https://player.vimeo.com/video/207299666" width="640" height="316" frameborder="0" webkitallowfullscreen mozallowfullscreen allowfullscreen&gt;&lt;/iframe&gt;&lt;/p&gt;
&lt;h3&gt;長度60連桿&lt;/h3&gt;
&lt;p&gt;&lt;iframe src="https://player.vimeo.com/video/207300757" width="640" height="316" frameborder="0" webkitallowfullscreen mozallowfullscreen allowfullscreen&gt;&lt;/iframe&gt;&lt;/p&gt;
&lt;h3&gt;四連桿組合&lt;/h3&gt;
&lt;p&gt;&lt;iframe src="https://player.vimeo.com/video/207304049" width="640" height="316" frameborder="0" webkitallowfullscreen mozallowfullscreen allowfullscreen&gt;&lt;/iframe&gt;&lt;/p&gt;
&lt;h2&gt;心得&lt;/h2&gt;
&lt;p&gt;&lt;p&gt; 1.利用第一周熟悉Solvespace 與 Onshape繪圖與模擬以及組合(包含快捷鍵複習) &lt;/p&gt;
&lt;p&gt; 2.熟悉git submodule指令 &lt;/p&gt;
&lt;p&gt; 3.了解這學期上課內容與每周進度 &lt;/p&gt;&lt;/p&gt;</summary><category term="solvespace與Onshape-W1"></category></entry></feed>